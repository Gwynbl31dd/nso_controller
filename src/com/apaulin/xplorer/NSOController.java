package com.apaulin.xplorer;

import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;

import com.apaulin.http.HttpRequest;
import com.apaulin.http.rest.HTTPException;
import com.apaulin.http.rest.RestRequest;
import com.apaulin.http.rpc.AppendListEntry;
import com.apaulin.http.rpc.Commit;
import com.apaulin.http.rpc.ConfirmCommit;
import com.apaulin.http.rpc.Create;
import com.apaulin.http.rpc.Delete;
import com.apaulin.http.rpc.Exists;
import com.apaulin.http.rpc.GetLeafRefValues;
import com.apaulin.http.rpc.GetListKeys;
import com.apaulin.http.rpc.GetSchema;
import com.apaulin.http.rpc.GetSystemSetting;
import com.apaulin.http.rpc.NewTrans;
import com.apaulin.http.rpc.RCPparameterException;
import com.apaulin.http.rpc.RPCException;
import com.apaulin.http.rpc.RunAction;
import com.apaulin.http.rpc.SetTransactionComment;
import com.apaulin.http.rpc.SetValue;
import com.apaulin.http.rpc.ShowConfig;
import com.apaulin.http.rpc.Abort;
import com.apaulin.http.rpc.ValidateCommit;
import com.apaulin.http.rpc.options.CommitOptions;
import com.apaulin.http.rpc.Load;
import com.apaulin.xplorer.exception.NSOException;

import com.apaulin.xplorer.json.JSONDisplay;
import com.apaulin.xplorer.json.ResultParser;
import com.github.cliftonlabs.json_simple.JsonException;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.PathNotFoundException;

import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;

import java.util.ArrayList;
import java.util.Random;

/**
 * Controller of the NSO request. This is basically an abstraction layer for the
 * requests object with an extra control.
 * 
 * @author Anthony Paulin
 * @since 22/07/2018
 * @version 1.4
 * 
 */

public class NSOController {
	private HttpRequest req;
	private int id; //Id used for the request.Can be a random id. Only used for RPC methods
	private boolean transactionInProgress = false; //Verification if the transaction has been started prior to use any RPC requests.
	private int transactionId; //ID generated by RPC when a transaction has been requested.
	private String address; // Address of the NSO instance. (http://IP:PORT)
	private String login; // Login used by the NSO instance (PAM or aaa database)
	private String password; // password used for the NSO instance (PAM or aaa database)
	private static final String VERSION = "2.0.0"; //Version of the library
	private int major_version;
	private int minor_version;
	private boolean commitValidated = false;//Check if the commit has been validated before a commit
	public static final String ROBOT_LIBRARY_SCOPE = "GLOBAL"; //Scope used for Robot framework.
	
	/**
	 * Default constructor - Should be used only by robot framework when called as a test library. 
	 * If you call it as a Java library, you should call NSOController(String address, String user, String password,(int id)) 
	 * For Robot framework, you must call the method init(String address, String user, String password) 
	 */
	public NSOController() {}

	/**
	 * Initialize the connection 
	 * Example: 
	 * NSOController nso = new NSOController("http://127.0.0.1:8080","admin","admin");
	 * 
	 * @param address 
	 * - Format http(s)://IP:PORT 
	 * @param user  
	 * -  username for the NSO connection   
	 * @param password 
	 * -  password for the NSO connection  
	 * @throws NSOException 
	 */
	public NSOController(String address, String user, String password) throws NSOException {
		init(address, user, password);
	}

	/**
	 * Build the NSO Controller access 
	 * Example: 
	 * NSOController nso = new NSOController("http://127.0.0.1:8080","admin","admin",5);
	 * 
	 * selecting an ID can be used if you want to manage your own IDs, for example
	 * if you use a multi-threads process.
	 * 
	 * @param address 
	 * - Format http(s)://IP:PORT 
	 * @param user  
	 * -  username for the NSO connection   
	 * @param password 
	 * -  password for the NSO connection 
	 * @param id 
	 * - The ID is used by RPC. But default it is a random integer generated by the library. 
	 * @throws NSOException 
	 */
	public NSOController(String address, String user, String password, int id) throws NSOException {
		this.setId(id);
		this.address = address;
		this.login = user;
		this.password = password;
		setReq(new HttpRequest(address + "/jsonrpc", user, password, getId()));
	}
	
	/**
	 * Initialize the connection 
	 * This should only be used by robot framework to init a new object. 
	 * For java, you should used the constructor NSOController(String address, String user, String password)
	 * 
	 * @param address 
	 * - Format http(s)://IP:PORT 
	 * @param user  
	 * -  username for the NSO connection  
	 * @param password 
	 * -  password for the NSO connection 
	 * @throws NSOException 
	 */
	public void init(String address, String user, String password) throws NSOException {
		this.setId();
		this.address = address;
		this.login = user;
		this.password = password;
		HttpRequest logReq = new HttpRequest(address + "/jsonrpc", user, password, getId());
		setReq(logReq);
	}

	/**
	 * Get using REST API
	 * Example : String result = nso.restGet("/config/aaa");
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @return return the request result (by default, in JSON String)
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String restGet(String path) throws HTTPException, NSOException {
		//Test if the application supports application/vnd.yang.collection+json
		String header = restHead(path);
		String headerToUse = "application/vnd.yang.collection+json";
		if(header.compareTo("Content-Type: text/json")==0) {
			headerToUse = "application/vnd.yang.data+json";
		}
		return new RestRequest().get(path, address, login, password,headerToUse);
	}
	
	/**
	 * Get the HEAD value of the equivalent of a GET request.
	 * Default value = "application/vnd.yang.collection+json"
	 * Can be use to determine the header required for GET
	 * Example : String result = nso.restHead("/config/aaa");
	 * 
	 * @param path  Path to the leaf
	 * @return THe header as a String Ex: "Content-Type: text/json"
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restHead(String path) throws HTTPException, NSOException{
			return restHead(path,"application/vnd.yang.collection+json");
	}
	
	/**
	 * Get the HEAD value of the equivalent of a GET request.
	 * Can be use to determine the header required for GET
	 * Example : String result = nso.restHead("/config/aaa","application/vnd.yang.collection+xml");
	 * 
	 * @param path  Path to the leaf
	 * @return THe header as a String Ex: "Content-Type: text/xml"
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restHead(String path, String request) throws HTTPException, NSOException{
		String req = null;
		try {
			req = new RestRequest().head(path, address, login, password, request);
		}
		catch(IOException e) {
			throw new NSOException(e);
		}
		return req;
	}
	
	/**
	 * Get using REST API
	 * Example : String result = nso.restHead("/config/aaa","application/vnd.yang.collection+json");
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param header
	 * - http header requested / E.g : application/vnd.yang.collection+json
	 * - Refer to the NSO documentation for more information.
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String restGet(String path,String header) throws HTTPException, NSOException {
		return new RestRequest().get(path, address, login, password,header);
	}

	/**
	 * Validate the commit for the current transaction
	 * This will explicitely valide the commit before running it.
	 * Example : 
	 * nso.validateCommit();
	 * nso.commitDryRunNative();
	 * nso.validateCommit();
	 * nso.commit();
	 * 
	 * @return JSON result of the commit validation
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String validateCommit() throws RPCException, NSOException {
		testTransaction();
		String parsedResult = ResultParser.processRawData(new ValidateCommit(transactionId), req);
		setCommitValidated(true);//Set the commit validation to true
		return parsedResult;
	}

	/**
	 * Commit the transaction
	 * If the commit validation has not been done before, this will 
	 * run a commit validation.
	 * Example : nso.commit(); 
	 * is equivalent to 
	 * nso.validateCommmit();
	 * nso.commit();
	 * 
	 * @param timeout / If set to zero, need to confirm the commit
	 * @return  The JSON Result form the commit
	 * @throws RPCException
	 * @throws NSOException 
	 */
	public String commit(int timeout) throws RPCException, NSOException  {
		testTransaction();
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(transactionId,timeout), req);
		transactionInProgress = false;//If the commit is a success, the transaction is killed
		return commitResult;
	}
	
	/**
	 * Same as commit, but provide a Force LSA Option
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitLSA() throws RPCException, NSOException {
		CommitOptions options = new CommitOptions();
		options.addUseLSA();
		
		testTransaction();
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(transactionId,options,0), req);
		transactionInProgress = false;//If the commit is a success, the transaction is killed
		return commitResult;
	}
	/**
	 * Commit the transaction
	 * If the commit validation has not been done before, this will 
	 * run a commit validation.
	 * Example : nso.commit(); 
	 * is equivalent to 
	 * nso.validateCommmit();
	 * nso.commit();
	 * 
	 * The default timeout is 600. 
	 * 
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commit() throws RPCException, NSOException {
		return this.commit(600);
	}
	
	/**
	 * Simple commit
	 * @param comment
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	@Deprecated
	public String commit(String comment) throws RPCException,NSOException {
		return this.commit();
	}
	
	/**
	 * Set the commit comment
	 * @param comment
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String setComment(String comment) throws RPCException, NSOException {
		String result = ResultParser.processRawData(new SetTransactionComment(transactionId,comment), req);
		return result;
	}

	/**
	 * Delete a leaf
	 * Example : nso.delete("/devices/device{myDevice}");
	 * 
	 * This is the equivalent of the NSO cisco CLI "no" in config mode
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @return JSON string result
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String delete(String path) throws RPCException, NSOException{
		testTransaction();
		return ResultParser.processRawData(new Delete(transactionId, path), req);
	}
	
	
	/**
	 * Commit dry run using the native format
	 * Example : nso.commitDryRunNative();
	 * This is equivalent of  doing :
	 * nso.validateCommit();
	 * nso.commitDryRunNative();
	 * 
	 * @param  timeout / Set it to zero for version >= 4.7.X 
	 * @return The command that the device will run
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String commitDryRunNative(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("native");
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		return ResultParser.processRawData(new Commit(transactionId, options, timeout), req);
	}
	
	/**
	 * Commit dry run using the native format
	 * Example : nso.commitDryRunNative();
	 * This is equivalent of  doing :
	 * nso.validateCommit();
	 * nso.commitDryRunNative();
	 * 
	 * This set the default timeout at 600
	 * 
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitDryRunNative() throws RPCException, NSOException {
		return this.commitDryRunNative(600);
	}

	/**
	 * Equivalent to dryRun();
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitDryRunCli() throws RPCException, NSOException {
		return this.dryRun();
	}
	
	/**
	 * Equivalent to dryRun(int timeout);
	 * @param timeout
	 * @return
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitDryRunCli(int timeout) throws RPCException, NSOException {
		return this.dryRun(timeout);
	}
	
	/**
	 * Run a dry run using the CLI (Default on NSO) option
	 * Prefer dry run native for JSON, because CLI will return a String using 
	 * + - and is difficult to process.
	 * @param timeout
	 * @return
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public String dryRun(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("cli");//Add CLI flag
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		String rawData = ResultParser.processRawData(new Commit(transactionId, options, timeout), req);
		String parsedResult = new String();
		try {
			//This is most probably a LSA output.
			if(rawData.contains("local_node") && rawData.contains("lsa_node") ) {
				parsedResult = ResultParser.parseStringResult(rawData,"$.dry_run_result.cli.local_node.data");
				parsedResult += ResultParser.parseStringResult(rawData,"$.dry_run_result.cli.lsa_node.*.data");
			}
			else {
				parsedResult = ResultParser.parseStringResult(rawData,"$.dryrun.cli");
			}
		}
		catch(Exception e) {
			e.printStackTrace();
			//In case of error, we process the rawData directly
			parsedResult = rawData;
		}
		return parsedResult;
	}
	
	/**
	 * Run a dry run using the CLI (Default on NSO) option
	 * Prefer dry run native for JSON, because CLI will return a String using 
	 * + - and is difficult to process.
	 * 
	 * Default timeout 600
	 * 
	 * @return
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public String dryRun() throws RPCException, NSOException {
		return this.dryRun(600);
	}
	
	/**
	 * Run a commit with the no networking flag (No modification on the device(s))
	 * @param timeout
	 * @return The commit result from NSO
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitNoNetworking(int timeout) throws RPCException,NSOException{
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addNoNetworking();
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(transactionId, options,timeout), req);
		transactionInProgress = false;//If the commit is a success, the transaction is killed
		return commitResult;
	}
	
	/**
	 * Run a commit with the no networking flag (No modification on the device(s))
	 * 
	 * default timeout : 600
	 * 
	 * @return The commit result from NSO
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String commitNoNetworking() throws RPCException, NSOException {
		return this.commitNoNetworking(600);
	}
	
	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse();
	 * This is equivalent of  doing :
	 * nso.validateCommit();
	 * nso.commitDryRunReverse();
	 * 
	 * @param timeout
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String commitDryRunReverse(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("native");
		options.addDryRunReverse();
		if(isCommitValidated() == false) {
			validateCommit();
		}
		setCommitValidated(false);
		return ResultParser.processRawData(new Commit(transactionId, options,timeout), req);
	}
	
	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse();
	 * This is equivalent of  doing :
	 * nso.validateCommit();
	 * nso.commitDryRunReverse();
	 * 
	 * Default timeout 600
	 * 
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String commitDryRunReverse() throws RPCException, NSOException {
		return this.commitDryRunReverse(600);
	}

	/**
	 * Return the packages with packages version
	 * Example : String packages = nso.getPackagesVersion();
	 * 
	 * @return List (as a string) of the packages
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String getPackagesVersion() throws HTTPException, NSOException  {
		String result = new RestRequest().get("/operational/packages/package/", address, login, password);
		JSONArray names = JsonPath.read(result, "$.collection.tailf-ncs:package[*].name");
		JSONArray versions = JsonPath.read(result, "$.collection.tailf-ncs:package[*].package-version");
		String processedResult = new String();
		for (int i = 0; i < names.size(); i++) {
			processedResult = processedResult + names.get(i) + " " + versions.get(i) + "\n";
		}
		return processedResult;
	}

	/**
	 * Return a list of device name on the NSO instance
	 * Example : String devices = nso.getDevicesSummary();
	 * 
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String getDevicesSummary() throws HTTPException, NSOException  {
		String result = new RestRequest().get("/config/devices", address, login, password,"application/vnd.yang.data+json");
		JSONArray names = JsonPath.read(result, "$.tailf-ncs:devices.device[*].name");
		String processedResult = new String();
		for (int i = 0; i < names.size(); i++) {
			processedResult = processedResult + names.get(i) + "\n";
		}
		return processedResult;
	}
	
	/**
	 * TODO In progress
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 * @throws RPCException 
	 */
	public String getDevicesDetails() throws HTTPException, NSOException, RPCException  {
		String result = this.showConfig("/devices");
		return result;
	}
	
	/**
	 * TODO In progress
	 * @param path
	 * @return
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public String getListKeys(String path) throws RPCException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new GetListKeys(transactionId, path), req);
		return result;
	}
	
	/**
	 * Append a list entry to a leaf-list.
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param value
	 * - Value to add to the leaf
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public void appendListEntry(String path, String value) throws NSOException, RPCException  {
		testTransaction();
		String result = req.postRequest(new AppendListEntry(transactionId, path, value));
		JSONObject error = ResultParser.parseError(result);
		if (error != null) {
			throw new RPCException(error.toString());
		}
	}

	/**
	 * Gets all possible values for a leaf with a leafref type
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @return
	 * @throws NSOException 
	 * @throws RPCException
	 * 
	 */
	public String getLeafRefValues(String path) throws NSOException, RPCException {
		testTransaction();
		String result = req.postRequest(new GetLeafRefValues(transactionId, path));
		return result;
	}

	/**
	 * Confirms the currently pending confirmed commit
	 * 
	 * @return
	 * @throws NSOException 
	 * @throws KeyManagementException
	 * @throws NoSuchAlgorithmException
	 * @throws KeyStoreException
	 * @throws IOException
	 * @throws RPCException
	 */
	public String confirmCommit() throws NSOException, RPCException {
		testTransaction();
		String result = req.postRequest(new ConfirmCommit(transactionId));
		return result;
	}

	/**
	 * Format the packages version for robot
	 * 
	 * @deprecated
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String getPackagesVersionFormated() throws HTTPException, NSOException {
		String result = new RestRequest().get("/operational/packages/package/", address, login, password);
		JSONArray names = JsonPath.read(result, "$.collection.tailf-ncs:package[*].name");
		JSONArray versions = JsonPath.read(result, "$.collection.tailf-ncs:package[*].package-version");
		String processedResult = new String();
		for (int i = 0; i < names.size(); i++) {
			processedResult = processedResult + "/packages/package{" + names.get(i) + "}/package-version "
					+ versions.get(i) + "\n";
		}
		return processedResult;
	}

	/**
	 * Validate the packages from a package list
	 * 
	 * @param toCheck
	 * - List of packages to check, separated by a new line separator.
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String ValidatePackages(String toCheck) throws HTTPException, NSOException  {
		String packagesOnNSO = getPackagesVersionFormated();
		String[] parts = toCheck.split(System.lineSeparator());
		ArrayList<String> toRaise = new ArrayList<String>();
		String toSend = new String();
		for (int i = 0; i < parts.length; i++) {
			if (!packagesOnNSO.contains(parts[i])) {
				toRaise.add(parts[i]);
			}
		}
		if (toRaise.size() != 0) {
			for (int i = 0; i < toRaise.size(); i++) {
				toSend += toRaise.get(i) + "\n";
			}
			toSend += "But got :\n" + packagesOnNSO;
		}
		return packagesOnNSO + " " + toSend;
	}

	/**
	 * Return the post request from the rest API
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws HTTPException 
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public String restPost(String path, String data) throws NSOException, HTTPException, RPCException {
		String result = new RestRequest().post(path, address, login, password, data);
		// If error
		if (result.contains("error-message")) {
			throw new RPCException(result);
		}
		return result;
	}
	
	/**
	 * Return the post request from the rest API
	 * 
	 * @param path
	 * @return
	 * @throws NSOException
	 * @throws HTTPException
	 * @throws RPCException
	 */
	public String restPost(String path) throws NSOException, HTTPException, RPCException {
		return this.restPost(path, "{}");
	}

	/**
	 * Patch data via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public void restPatch(String path, String data) throws HTTPException, NSOException {
		try {
			new RestRequest().patch(path, address, login, password, data);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple patch
		}
	}
	
	/**
	 * Put data via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public void restPut(String path, String data) throws HTTPException, NSOException {
		try {
			new RestRequest().put(path, address, login, password, data);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple patch
		}
	}

	/**
	 * Put with dry run via REST
	 * This uses the native output by default
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String restPutDryRun(String path, String data) throws HTTPException, NSOException  {
		return this.restPutDryRun(path, data,"native");
	}
	
	/**
	 * Put with dry run via REST
	 * 
	 * @param path
	 * - Path 
	 * @param data
	 * - KeyPath String expression
	 * @param type
	 * - type (cli, native)
	 * @return
	 * @throws HTTPException
	 * @throws NSOException
	 */
	public String restPutDryRun(String path, String data,String type) throws HTTPException, NSOException  {
		String result = new RestRequest().put(path + "?dryrun="+type, address, login, password, data);
		return result;
	}
	
	/**
	 * Put with dry run native via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String restPutDryRunNative(String path, String data) throws HTTPException, NSOException {
		return this.restPutDryRun(path,data);
	}
	
	/**
	 * Put with dry run cli via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public String restPutDryRunCli(String path, String data) throws HTTPException, NSOException {
		return this.restPutDryRun(path,data,"cli");
	}
	
	/**
	 * Patch with dry run via REST
	 * Default native
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restPatchDryRun(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "native");
	}
	
	/**
	 * Patch with dry run via REST
	 * 
	 * @param path
	 * - Path
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @param type
	 * - type (cli, native)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restPatchDryRun(String path, String data,String type) throws HTTPException, NSOException {
		String result = new RestRequest().patch(path + "?dryrun="+type, address, login, password, data);
		return result;
	}
	
	/**
	 * Patch with dry run cli via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restPatchDryRunCli(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "cli");
	}

	/**
	 * Patch with dry run native via REST
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restPatchDryRunNative(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "cli");
	}
	
	/**
	 * Delete a service using REST
	 * 
	 * @param path
	 * - URL path to the service (Refer to the NSO doc for the http request path) this is different to the KeyPath.
	 * @throws NSOException 
	 * @throws HTTPException
	 */
	public void restDelete(String path) throws HTTPException, NSOException{
		try {
			new RestRequest().delete("/api/config" + path, address, login, password);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple delete
		}
	}

	/**
	 * Delete dry-run using rest
	 * Default native
	 * @param path
	 * - URL path to the service (Refer to the NSO doc for the http request path) this is different to the KeyPath.
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restDeleteDryRun(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path, "native");
	}
	
	/**
	 * Delete dry-run using rest
	 * Default native
	 * @param path
	 * - URL path to the service (Refer to the NSO doc for the http request path) this is different to the KeyPath.
	 * @param 
	 * - type (cli,native)
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restDeleteDryRun(String path,String type) throws HTTPException, NSOException {
		return new RestRequest().delete("/api/config" + path + "?dryrun="+type, address, login, password);
	}
	
	/**
	 * Delete dry-run native using rest
	 * 
	 * @param path
	 * - URL path to the service (Refer to the NSO doc for the http request path) this is different to the KeyPath.
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restDeleteDryRunNative(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path);
	}
	
	/**
	 * Delete dry-run cli using rest
	 * 
	 * @param path
	 * - URL path to the service (Refer to the NSO doc for the http request path) this is different to the KeyPath.
	 * @return
	 * @throws NSOException 
	 * @throws HTTPException 
	 */
	public String restDeleteDryRunCli(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path,"cli");
	}
	
	/**
	 * Send data by REST and commit dry-run it (default native) (post)
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @return
	 * @throws HTTPException 
	 * @throws NSOException 
	 */
	public String restDryRun(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data,"native");
	}
	
	/**
	 * Send data by REST and commit dry-run it (post)
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Data payload to send (In JSON format)
	 * @param type
	 * - type (cli,native)
	 * @return
	 * @throws NSOException
	 * @throws HTTPException
	 */
	public String restDryRun(String path, String data,String type) throws NSOException, HTTPException {
		String result = new RestRequest().post(path + "?dryrun="+type, address, login, password, data);
		return result;
	}
	
	/**
	 * end data by REST and commit dry-run native (post)
	 * 
	 * @param path
	 * @param data
	 * @return
	 * @throws NSOException
	 * @throws HTTPException
	 */
	public String restDryRunNative(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data);
	}
	
	/**
	 * end data by REST and commit dry-run cli (post)
	 * 
	 * @param path
	 * @param data
	 * @return
	 * @throws NSOException
	 * @throws HTTPException
	 */
	public String restDryRunCli(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data,"cli");
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - String data
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String setValue(String path, String data) throws RPCException, NSOException  {
		testTransaction();
		return ResultParser.processRawData(new SetValue(transactionId, path, data), req);
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Boolean value
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String setValue(String path, boolean data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(transactionId, path, data), req);
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @param data
	 * - Integer value
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String setValue(String path, int data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(transactionId, path, data), req);
	}

	/**
	 * Abort a JSON-RPC method by its associated id.
	 * 
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String abort() throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Abort(id), req);
	}

	/**
	 * Create a list entry, a presence container, or a leaf of type empty
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String create(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Create(transactionId, path), req);
	}

	/**
	 * Start a new transaction
	 * 
	 * @param db
	 * - "startup", "running", "candidate" 
	 * @param mode
	 * - "read", "read_write" 
	 * @param conf_mode
	 * - "private", "shared", "exclusive"
	 * @param tag
	 * - Tag use for the rollback system
	 * @param on_pending_change
	 * - "reuse", "reject", "discard"
	 * @return
	 * @throws RPCException 
	 * @throws RCPparameterException 
	 * @throws NSOException 
	 */
	public int startTransaction(String db, String mode, String conf_mode, String tag, String on_pending_change) throws  NSOException, RPCException, RCPparameterException {
		String requestValue = req.postRequest(new NewTrans(db, mode, conf_mode, tag, on_pending_change));
		int th = 0;
		try {
		th = JsonPath.read(requestValue,"$.result.th");
		this.setTransactionInProgress(true);// Set the transaction to true
		this.transactionId = th;
		}
		catch(PathNotFoundException e) {
			throw new RPCException(requestValue);
		}
		getNSOVersion();//Initiate NSO version
		return th;// Return the transaction number
	}
	
	public int startTransaction() throws  NSOException, RPCException, RCPparameterException {
		return startTransaction("running", "read_write", "private", "test", "reuse");
	}

	/**
	 * Get the data model
	 * 
	 * @param path
	 * - KeyPath String expression
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String getModel(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetSchema(transactionId, path), req);
	}
	
	/**
	 * Test the transaction
	 * 
	 * @throws RPCException
	 * @throws RCPparameterException 
	 * @throws NSOException 
	 */
	private void testTransaction() throws RPCException, NSOException {
		if (transactionInProgress == false) {
			//throw new RPCException("No transaction initated, make sure you start a transaction before any call");
			try {
				startTransaction();//Instead of throwing an exception, start a new one
				transactionInProgress = true;//Set the transaction in progress
			} catch (RCPparameterException e) {
				throw new NSOException(e);
			}
		}
	}

	/**
	 * Try a sync from but does not valid the devices
	 * Example : nso.syncFrom();
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String syncFrom() throws RPCException, NSOException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, "/devices/sync-from"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			if (type.compareTo("sync-result/device") == 0) {
				processed += value + ":";
			} else if (type.compareTo("sync-result/result") == 0) {
				processed += value + "\n";
			}
		}
		return processed;
	}
	
	/**
	 * Execute sync from on a specific device
	 * @param deviceName the device name on NSO
	 * @return a boolean, true if the device in in Sync, false if not
	 * @throws RPCException
	 * @throws NSOException
	 */
	public boolean syncFrom(String deviceName) throws RPCException, NSOException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, "/devices/device{"+deviceName+"}/sync-from"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = syncs.toJSONString();
		for (int i = 0; i < syncs.size(); i++) {
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed = value;
		}
		return Boolean.valueOf(processed);
	}
	
	/**
	 * Run an action from NSO
	 * Example : nso.runAction("/devices/sync-from");
	 * @param action
	 * - KeyPath String expression to the action
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String runAction(String action) throws RPCException, NSOException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, action));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value;
		}
		return processed;
	}

	/**
	 * Load a file to NSO
	 * 
	 * Example : nso.load("/devices/device{devicename}","/tmp/device.xml","replace","xml");
	 * 
	 * @param path
	 * - Keypath String expression
	 * @param filePath
	 * - path to the file (from the system calling it)
	 * @param mode
	 * - "create","merge","replace"
	 * @param format
	 * - "json","xml"
	 * @return
	 * @throws RCPparameterException
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String load(String path,String filePath,String mode,String format) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(transactionId,path,filePath,mode,format), req);
	}
	
	/**
	 * Load a file to NSO 
	 * By default, the file will be merged, and using JSON.
	 * Use load(String path,String filePath,String mode,String format) for more options
	 * 
	 * Example : nso.load("/devices/device{devicename}","/tmp/device.json");
	 * 
	 * @param path
	 *  -  KeyPath String expression
	 * @param filePath
	 * 	-  path to the file (from the system calling it)
	 * @return
	 * @throws RPCException
	 * @throws RCPparameterException
	 * @throws NSOException
	 */
	public String load(String path,String filePath) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(transactionId,path,filePath,"merge","json"), req);
	}
	
	/**
	 * Check the service sync
	 * 
	 * @param path
	 * - KeyPath String expression to the service
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String serviceCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, path + "/check-sync"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value +" ";
		}
		return processed;
	}
	
	/**
	 * Check the device synchronization
	 * 
	 * Return true on any case. Will return a RPCException if the device is out
	 * of sync.
	 * 
	 * @param device
	 *            The device name
	 * @return The status
	 * @throws NSOException
	 * @throws RPCException
	 */
	public boolean deviceCheckSync(String device) throws RPCException, NSOException {		
		String result = serviceCheckSync("/devices/device{"+device+"}");
		if(result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}
	
	/**
	 * Check the devices synchronization 
	 * 
	 * Same as deviceCheckSync(String device),
	 * but return a RPCException if one of the device is out of sync.
	 * 
	 * @param device   The device name
	 * @return  The status
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public boolean deviceCheckSync() throws RPCException, NSOException {		
		String result = serviceCheckSync("/devices");
		if(result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}

	/**
	 * Return deep check sync
	 * Example : nso.serviceDeepCheckSync("/services/myservice");
	 * @param path
	 * - KeyPath String expression to the service
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String serviceDeepCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, path + "/deep-check-sync"));
		JSONObject error = ResultParser.parseError(result);
		// If no error
		if (error != null) {
			throw new RPCException(error.toString());
		}
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value;
		}
		return processed;
	}

	/**
	 * Call default live-status action (exec)
	 * 
	 * This works with any of the latest version of NSO.
	 * For the older version, you will need to use
	 * String liveStatus(String device, String cmd, String action)
	 * to specify the device type.(Ex: cisco-iosxr)
	 * 
	 * @param device
	 * - device name
	 * @param cmd
	 * - command to send to the device
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String liveStatus(String device, String cmd) throws NSOException, RPCException  {
		return this.liveStatus(device, cmd, "exec");
	}
	
	

	/**
	 * Can use different action (ex : exec, bigip-actions,...)
	 * 
	 * @param device
	 * - device name
	 * @param cmd
	 * - command to send to the device
	 * @param action
	 * - exec, bigip-actions,...
	 * @return
	 * @throws NSOException 
	 * @throws RPCException 
	 */
	public String liveStatus(String device, String cmd, String action) throws NSOException, RPCException {
		testTransaction();
		String result = req.postRequest(new RunAction(transactionId, "/devices/device{" + device + "}/live-status/" + action + "/any/", cmd));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			if (type.compareTo("result") == 0) {
				processed += value;
			}
		}
		return processed;
	}
	
	/**
	 * Check if a leaf exists
	 * 
	 * @param path
	 * - KeyPath String expression to the leaf
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public boolean isExisting(String path) throws RPCException, NSOException {
		String data = ResultParser.processRawData(new Exists(transactionId, path), req);
		boolean result = ResultParser.parseBool(data, "$.exists");
		return result;
	}

	/**
	 * Log out from the NPC session
	 * This should always be called after your operations.
	 * If not, NSO will keep the session open.
	 * 
	 * @return
	 */
	public String logout()  {
		try {
			return ResultParser.processRawData(new com.apaulin.http.rpc.Logout(), req);
		}
		catch(Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Show the config as a string (Default)
	 * 
	 * @param path
	 * - KeyPath String expression to the leaf
	 * @return
	 * @throws RPCException 
	 * @throws NSOException 
	 */
	public String showConfig(String path) throws RPCException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new ShowConfig(transactionId, path), req);
		return ResultParser.parseStringResult(result, "$.config");
	}
	
	/**
	 * Show a specific device config as JSON string
	 * Example : String result = nso.showDeviceConfig("mydevice");
	 * @param device The device name
	 * @return String JSON Value
	 * @throws RPCException
	 * @throws NSOException
	 */
	public String showDeviceConfig(String device) throws RPCException, NSOException {
		return showConfig("/devices/device/{"+device+"}");
	}

	/**
	 * Show the config (Can be "string" or "json")
	 * 
	 * @param path
	 * - KeyPath String expression to the leaf
	 * @param resultAs
	 * - "string","json"
	 * @return
	 * @throws RPCException 
	 * @throws RCPparameterException 
	 * @throws NSOException 
	 */
	public String showConfig(String path, String resultAs) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new ShowConfig(transactionId, path, resultAs, false, 0), req);
		if (resultAs.compareTo("string") == 0) {
			return ResultParser.parseStringResult(result, "$.config");
		} else {
			JSONObject jO = JsonPath.parse(result).read("$.data", JSONObject.class);
			return jO.toJSONString();
		}
	}

	/**
	 * Return the NSOVersion
	 * 
	 * @return
	 * @throws RPCException 
	 * @throws RCPparameterException 
	 * @throws NSOException 
	 */
	public String getNSOVersion() throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String parsedResult = ResultParser.parseStringResult(req.postRequest(new GetSystemSetting(transactionId, "version")), "$.result");
		//Version major and minor can be use to manage the capabilities from the NSO version used.
		this.major_version = Integer.parseInt(parsedResult.split("\\.")[0]);
		this.minor_version = Integer.parseInt(parsedResult.split("\\.")[1]);
		return ResultParser.parseStringResult(req.postRequest(new GetSystemSetting(transactionId, "version")), "$.result");
	}
	
	/**
	 * Get the Minor NSO version
	 * Example : 4.5.3 -> Minor is 5
	 * @return
	 */
	public int getMinorVersion() {
		return this.minor_version;
	}
	
	/**
	 * Get the Major NSO Version
	 * Example : 4.5.3 -> Major is 4
	 * @return
	 */
	public int getMajorVersion() {
		return this.major_version;
	}
	/**
	 * Return the NSO Settings
	 * 
	 * @return
	 * @throws RPCException 
	 * @throws RCPparameterException 
	 * @throws JsonException 
	 * @throws NSOException 
	 */
	public String getNSOSettings() throws RPCException, JsonException, RCPparameterException, NSOException  {
		testTransaction();
		return new JSONDisplay(ResultParser.processRawData(new GetSystemSetting(transactionId, "all"), req)).getJsonString();
	}

	/**
	 * @return the id of the session
	 */
	public int getId() {
		return id;
	}

	/**
	 * Set a random id for the session (called by default)
	 */
	private void setId() {
		Random rand = new Random();
		this.id = rand.nextInt(100) + 1;
	}

	/**
	 * Set the ID
	 * 
	 * @param id
	 */
	private void setId(int id) {
		this.id = id;
	}

	/**
	 * 
	 * @return the req
	 * @throws RPCException
	 * @throws NSOException 
	 */
	public HttpRequest getReq() throws RPCException, NSOException {
		testTransaction();
		return req;
	}

	/**
	 * Return the HTTPRequest object
	 * @param req
	 * - the request to set
	 */
	public void setReq(HttpRequest req) {
		this.req = req;
	}

	/**
	 * Check is a transaction is in progress (can be true or false)
	 * @return the transactionInProgress
	 */
	public boolean isTransactionInProgress() {
		return transactionInProgress;
	}

	/**
	 * Set the transaction in progress (Should not be called manually)
	 * @param transactionInProgress
	 * the transactionInProgress to set
	 */
	private void setTransactionInProgress(boolean transactionInProgress) {
		this.transactionInProgress = transactionInProgress;
	}

	/**
	 * Return the transaction id (th) without a new request (local saved)
	 * This will not work if you managed your transaction yourself
	 * 
	 * @return
	 */
	public int getTransactionId() {
		return transactionId;
	}

	/**
	 * Get Xplorer library version
	 * @return the version
	 */
	public static String getVersion() {
		return VERSION;
	}
	
	/**
	 * Expose the NSO representation
	 */
	public String toString() {
		return "NSO (Network service orchestrator) version "+this.major_version+"."+this.minor_version+".X API version"+VERSION;
	}

	/**
	 * This is used to check if you validated the commit
	 * @return the commitValidated
	 */
	public boolean isCommitValidated() {
		return commitValidated;
	}

	/**
	 * Modify the commit validation
	 * @param commitValidated the commitValidated to set
	 */
	private void setCommitValidated(boolean commitValidated) {
		this.commitValidated = commitValidated;
	}
}
