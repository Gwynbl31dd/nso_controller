package com.apaulin.nso_controller;

import java.io.FileReader;
import java.io.IOException;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import org.robotframework.javalib.annotation.RobotKeywords;

import com.apaulin.nso_controller.exception.NSOException;
import com.apaulin.nso_controller.http.RpcRequest;
import com.apaulin.nso_controller.http.RpcSession;
import com.apaulin.nso_controller.http.SessionManager;
import com.apaulin.nso_controller.http.StringArray;
import com.apaulin.nso_controller.http.rpc.Abort;
import com.apaulin.nso_controller.http.rpc.AppendListEntry;
import com.apaulin.nso_controller.http.rpc.Commit;
import com.apaulin.nso_controller.http.rpc.CommitOptions;
import com.apaulin.nso_controller.http.rpc.ConfirmCommit;
import com.apaulin.nso_controller.http.rpc.Create;
import com.apaulin.nso_controller.http.rpc.Delete;
import com.apaulin.nso_controller.http.rpc.Exists;
import com.apaulin.nso_controller.http.rpc.GetLeafRefValues;
import com.apaulin.nso_controller.http.rpc.GetListKeys;
import com.apaulin.nso_controller.http.rpc.GetSchema;
import com.apaulin.nso_controller.http.rpc.GetSystemSetting;
import com.apaulin.nso_controller.http.rpc.GetValue;
import com.apaulin.nso_controller.http.rpc.GetValues;
import com.apaulin.nso_controller.http.rpc.Load;
import com.apaulin.nso_controller.http.rpc.LoadString;
import com.apaulin.nso_controller.http.rpc.Logout;
import com.apaulin.nso_controller.http.rpc.NewTrans;
import com.apaulin.nso_controller.http.rpc.RCPparameterException;
import com.apaulin.nso_controller.http.rpc.RPCException;
import com.apaulin.nso_controller.http.rpc.RunAction;
import com.apaulin.nso_controller.http.rpc.SetValue;
import com.apaulin.nso_controller.http.rpc.ShowConfig;
import com.apaulin.nso_controller.http.rpc.ValidateCommit;
import com.apaulin.nso_controller.http.rpc.ValidateTrans;
import com.apaulin.nso_controller.json.JSONDisplay;
import com.apaulin.nso_controller.json.ResultParser;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.JsonPathException;
import com.jayway.jsonpath.PathNotFoundException;

import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;

/**
 * Controller of the NSO request. This is basically an abstraction layer for the
 * requests object with an extra control.
 * 
 * @author Anthony Paulin
 * @since 22/07/2018
 * @version 3.0
 * 
 */
@RobotKeywords
public class NSOController {

	private SessionManager sessionManager = new SessionManager();
	private String address; // Address of the NSO instance. (http://IP:PORT)
	private String login; // Login used by the NSO instance (PAM or aaa database)
	private String password; // password used for the NSO instance (PAM or aaa database)
	private int majorVersion;
	private int minorVersion;
	public static final String ROBOT_LIBRARY_SCOPE = "GLOBAL"; // Scope used for Robot framework.
	private static final Logger logger = LogManager.getLogger(NSOController.class);

	// JSON expressions
	private static final String RESULT_ARRAY = "$.result[*]";
	private static final String NAME = "$.name";
	private static final String VALUE = "$.value";
	private static final String RESULT = "$.result";

	/**
	 * Default constructor - Should be used only by robot framework when called as a
	 * test library. If you call it as a Java library, you should call
	 * NSOController(String address, String user, String password,(int id)) For
	 * Robot framework, you must call the method init(String address, String user,
	 * String password)
	 */
	public NSOController() {
	}

	/**
	 * Initialize the connection Example: NSOController nso = new
	 * NSOController("http://127.0.0.1:8080","admin","admin");
	 * 
	 * @param address  - Format http(s)://IP:PORT
	 * @param user     - username for the NSO connection
	 * @param password - password for the NSO connection
	 * @throws NSOException NSO related exception
	 */
	public NSOController(String address, String user, String password) throws NSOException {
		init(address, user, password);
	}

	/**
	 * Build the NSO Controller access Example: NSOController nso = new
	 * NSOController("http://127.0.0.1:8080","admin","admin",5);
	 * 
	 * selecting an ID can be used if you want to manage your own IDs, for example
	 * if you use a multi-threads process.
	 * 
	 * @param address  - Format http(s)://IP:PORT
	 * @param user     - username for the NSO connection
	 * @param password - password for the NSO connection
	 * @param id       - The ID is used by RPC. But default it is a random integer
	 *                 generated by the library.
	 * @throws NSOException NSO related exception
	 */
	public NSOController(String address, String user, String password, int id) throws NSOException {
		createSession(address, user, password, id);
	}

	/**
	 * Initialize the connection This should only be used by robot framework to init
	 * a new object. For java, you should used the constructor NSOController(String
	 * address, String user, String password)
	 * 
	 * @param address  - Format http(s)://IP:PORT
	 * @param user     - username for the NSO connection
	 * @param password - password for the NSO connection
	 * @throws NSOException NSO related exception if there is a NSO connection
	 *                      exception
	 */
	public void init(String address, String user, String password) throws NSOException {
		logger.info("Start init process");
		createSession(address, user, password, sessionManager.setId());
	}

	/**
	 * Create the session
	 * 
	 * @param address  - Format http(s)://IP:PORT
	 * @param user     - username for the NSO connection
	 * @param password - password for the NSO connection
	 * @param id       - id for the nso connection
	 * @throws NSOException NSO related exception
	 */
	private void createSession(String address, String user, String password, int id) throws NSOException {
		this.address = address;
		this.login = user;
		this.password = password;
		RpcRequest request = new RpcRequest(address + "/jsonrpc", user, password, id);
		RpcSession session = new RpcSession(id, request);
		sessionManager.add(session);// Add the new session to the list of sessions
		logger.info("Session created");
	}

	/**
	 * Add a new session
	 * 
	 * @throws NSOException NSO related exception
	 */
	public void addSession() throws NSOException {
		int id = sessionManager.setId();
		RpcRequest request = new RpcRequest(address + "/jsonrpc", login, password, id);
		RpcSession session = new RpcSession(id, request);
		sessionManager.add(session);// Add the new session to the list of sessions
		logger.info("Session added");
	}

	/**
	 * Validate the commit for the current transaction This will explicitly validate
	 * the commit before running it. Example : nso.validateCommit();
	 * nso.commitDryRunNative(); nso.validateCommit(); nso.commit();
	 * 
	 * @return JSON result of the commit validation
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception for NSO related exception
	 */
	public String validateCommit() throws RPCException, NSOException {
		logger.info("validate commit");
		testTransaction();
		String parsedResult = ResultParser.processRawData(new ValidateCommit(sessionManager.getTransactionId()),
				sessionManager.getCurrentReq());
		sessionManager.setCommitValidated(true);// Set the commit validation to true
		return parsedResult;
	}

	/**
	 * Validate a transaction
	 * 
	 * @return JSON result of the transaction validation
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception for NSO related exception
	 */
	public String validateTransaction() throws RPCException, NSOException {
		logger.info("validate transaction");
		testTransaction();
		return ResultParser.processRawData(new ValidateTrans(sessionManager.getTransactionId()),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit the transaction If the commit validation has not been done before,
	 * this will run a commit validation. Example : nso.commit(); is equivalent to
	 * nso.validateCommmit(); nso.commit();
	 * 
	 * @param timeout / If set to zero, need to confirm the commit
	 * @return The JSON Result form the commit
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String commit(int timeout) throws RPCException, NSOException {
		testTransaction();
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), timeout),
				sessionManager.getCurrentReq());
		// If the commit is a success, the transaction is killed
		sessionManager.getCurrentSession().setTransactionInProgress(false);
		return commitResult;
	}

	/**
	 * Same as commit, but provides a Force LSA Option
	 * 
	 * @return The commit's result
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String commitLSA() throws RPCException, NSOException {
		CommitOptions options = new CommitOptions();
		options.addUseLSA();
		testTransaction();
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, 0),
				sessionManager.getCurrentReq());
		// If the commit is a success, the transaction is killed
		sessionManager.getCurrentSession().setTransactionInProgress(false);
		return commitResult;
	}

	/**
	 * Commit the transaction If the commit validation has not been done before,
	 * this will run a commit validation. Example : nso.commit(); is equivalent to
	 * nso.validateCommmit(); nso.commit();
	 * 
	 * The default timeout is 600.
	 * 
	 * @return The commit result
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String commit() throws RPCException, NSOException {
		return this.commit(0);
	}

	/**
	 * Ping action to JRPC
	 * 
	 * @param device The device Name
	 * @return The ping result as a String
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String ping(String device) throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/device{" + device + "}/ping");
	}

	/**
	 * Connect action to JRPC
	 * 
	 * @param device The device Name
	 * @return The connect result as a String
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String connect(String device) throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/device{" + device + "}/connect");
	}

	/**
	 * Connect action to JRPC for all devices
	 * 
	 * @return The connect result as a String
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String connect() throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/connect");
	}

	/**
	 * Delete a leaf Example : nso.delete("/devices/device{myDevice}");
	 * 
	 * This is the equivalent of the NSO cisco CLI "no" in config mode
	 * 
	 * @param path - KeyPath String expression
	 * @return JSON string result
	 * @throws RPCException RPC related exception
	 * @throws NSOException for NSO related exception
	 */
	public String delete(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Delete(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit dry run using the native format Example : nso.commitDryRunNative();
	 * This is equivalent of doing : nso.validateCommit(); nso.commitDryRunNative();
	 * 
	 * @param timeout Set it to zero for version higher 4.7.X
	 * @return The command that the device will run
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          for NSO related exception
	 * @throws RCPparameterException RPC related Exception
	 */
	public String commitDryRunNative(int timeout) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun(CommitOptions.FORMAT_VALUES[3]);
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		return ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit dry run using the native format Example : nso.commitDryRunNative();
	 * This is equivalent of doing : nso.validateCommit(); nso.commitDryRunNative();
	 * 
	 * This set the default timeout at 0
	 * 
	 * @return Commit dry run result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          for NSO related exception
	 * @throws RCPparameterException
	 */
	public String commitDryRunNative() throws RPCException, NSOException, RCPparameterException {
		return this.commitDryRunNative(0);
	}

	/**
	 * Equivalent to dryRun();
	 * 
	 * @return commit dry run in cli format
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          for NSO related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String commitDryRunCli() throws RPCException, NSOException, RCPparameterException {
		return this.dryRun();
	}

	/**
	 * Equivalent to dryRun(int timeout);
	 * 
	 * @param timeout the timeout in ms
	 * @return commit dry run in cli format
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          for NSO related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String commitDryRunCli(int timeout) throws RPCException, NSOException, RCPparameterException {
		return this.dryRun(timeout);
	}

	/**
	 * Run a dry run using the CLI (Default on NSO) option Prefer dry run native for
	 * JSON, because CLI will return a String using + - and is difficult to process.
	 * 
	 * @param timeout the timeout in ms
	 * @return commit dry run in json (default)
	 * @throws NSOException          for NSO related exception
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String dryRun(int timeout) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("cli");// Add CLI flag
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String rawData = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
		String parsedResult = "";
		try {
			// This is most probably a LSA output.
			if (rawData.contains("local_node") && rawData.contains("lsa_node")) {
				parsedResult = ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.local_node.data");
				parsedResult += ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.lsa_node.*.data");
			} else if (rawData.contains("local_node")) {
				parsedResult = ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.local_node.data");
			} else {
				parsedResult = rawData;
			}
		} catch (Exception e) {
			e.printStackTrace();
			// In case of error, we process the rawData directly
			parsedResult = rawData;
		}
		return parsedResult;
	}

	/**
	 * Run a dry run using the CLI (Default on NSO) option Prefer dry run native for
	 * JSON, because CLI will return a String using + - and is difficult to process.
	 * 
	 * Default timeout 600
	 * 
	 * @return commit dry run (600ms default)
	 * @throws NSOException          for NSO related exception
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String dryRun() throws RPCException, NSOException, RCPparameterException {
		return this.dryRun(0);
	}

	/**
	 * Run a commit with the no-networking flag (No modification on the device(s))
	 * 
	 * @param timeout the timeout in ms
	 * @return The commit result from NSO
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String commitNoNetworking(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addNoNetworking();
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(
				new Commit(sessionManager.getTransactionId(), options, timeout), sessionManager.getCurrentReq());
		// If the commit is a success, the transaction is killed
		sessionManager.getCurrentSession().setTransactionInProgress(false);
		return commitResult;
	}

	/**
	 * Run a commit with the no networking flag (No modification on the device(s))
	 * 
	 * default timeout : 600
	 * 
	 * @return The commit result from NSO
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String commitNoNetworking() throws RPCException, NSOException {
		return this.commitNoNetworking(0);
	}

	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse(); This is equivalent of doing :
	 * nso.validateCommit(); nso.commitDryRunReverse();
	 * 
	 * @param timeout the timeout in ms
	 * @return the commit dry run reverse result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String commitDryRunReverse(int timeout) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun(CommitOptions.FORMAT_VALUES[3]);
		options.addDryRunReverse();
		if (!sessionManager.isCommitValidated()) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		return ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse(); This is equivalent of doing :
	 * nso.validateCommit(); nso.commitDryRunReverse();
	 * 
	 * Default timeout 600
	 * 
	 * @return the commit dry run reverse result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException RPC Related Exception
	 */
	public String commitDryRunReverse() throws RPCException, NSOException, RCPparameterException {
		return this.commitDryRunReverse(0);
	}

	/**
	 * Get a list of keys
	 * 
	 * @param path KeyPath String expression
	 * @return the list keys
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 */
	public String getListKeys(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetListKeys(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Append a list entry to a leaf-list.
	 * 
	 * @param path  - KeyPath String expression
	 * @param value - Value to add to the leaf
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 */
	public void appendListEntry(String path, String value) throws NSOException, RPCException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new AppendListEntry(sessionManager.getTransactionId(), path, value));
		JSONObject error = ResultParser.parseError(result);
		if (error != null) {
			throw new RPCException(error.toString());
		}
	}

	/**
	 * Gets all possible values for a leaf with a leafref type
	 * 
	 * @param path - KeyPath String expression
	 * @return the leaf ref values
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 * 
	 */
	public String getLeafRefValues(String path) throws NSOException, RPCException {
		testTransaction();
		return sessionManager.getCurrentReq().send(new GetLeafRefValues(sessionManager.getTransactionId(), path));
	}

	/**
	 * Confirms the currently pending confirmed commit
	 * 
	 * @return the confirm commit result
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 */
	public String confirmCommit() throws NSOException, RPCException {
		testTransaction();
		return sessionManager.getCurrentReq().send(new ConfirmCommit(sessionManager.getTransactionId()));
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path - KeyPath String expression
	 * @param data - String data
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String setValue(String path, String data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path - KeyPath String expression
	 * @param data - Boolean value
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String setValue(String path, boolean data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path - KeyPath String expression
	 * @param data - Integer value
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String setValue(String path, int data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get a leaf value
	 * 
	 * @param path         - KeyPath String expression
	 * @param checkDefault - Check default value
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String getValue(String path, boolean checkDefault) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetValue(sessionManager.getTransactionId(), path, checkDefault),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get a leaf value
	 * 
	 * @param path - KeyPath String expression
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String getValue(String path) throws RPCException, NSOException {
		return getValue(path, true);
	}

	/**
	 * Get leaf values
	 * 
	 * @param path  - KeyPath String expression
	 * @param leafs - the leafs param is an array of children names residing under
	 *              the parent container in the YANG module
	 * @return result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String getValues(String path, StringArray leafs) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetValues(sessionManager.getTransactionId(), path, leafs),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get leaf values
	 * 
	 * @param path - KeyPath String expression
	 * @return result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String getValues(String path) throws RPCException, NSOException {
		return getValues(path, new StringArray());
	}

	/**
	 * Abort a JSON-RPC method by its associated id.
	 * 
	 * @return the result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String abort() throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Abort(sessionManager.getCurrentSession().getId()),
				sessionManager.getCurrentReq());
	}

	/**
	 * Create a list entry, a presence container, or a leaf of type empty
	 * 
	 * @param path - KeyPath String expression
	 * @return result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String create(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Create(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Start a new transaction
	 * 
	 * @param db              - "startup", "running", "candidate"
	 * @param mode            - "read", "read_write"
	 * @param confMode        - "private", "shared", "exclusive"
	 * @param tag             - Tag use for the rollback system
	 * @param onPendingChange - "reuse", "reject", "discard"
	 * @return the transaction id
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException parameters exception
	 * @throws NSOException          NSO related exception
	 */
	public int startTransaction(String db, String mode, String confMode, String tag, String onPendingChange)
			throws NSOException, RPCException, RCPparameterException {
		logger.info("Start transaction");
		String requestValue = sessionManager.getCurrentReq()
				.send(new NewTrans(db, mode, confMode, tag, onPendingChange));
		int th = 0;
		try {
			th = JsonPath.read(requestValue, "$.result.th");
			sessionManager.getCurrentSession().setTransactionId(th);
			sessionManager.getCurrentSession().setTransactionInProgress(true);// Set the transaction to true
		} catch (PathNotFoundException e) {
			throw new RPCException(requestValue);
		}
		getNSOVersion();// Initiate NSO version
		return th;// Return the transaction number
	}

	public int startTransaction() throws NSOException, RPCException, RCPparameterException {
		return startTransaction("running", "read_write", "private", "test", "reuse");
	}

	/**
	 * Get the data model
	 * 
	 * @param path - KeyPath String expression
	 * @return the model
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String getModel(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetSchema(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Test the transaction
	 * 
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	private void testTransaction() throws RPCException, NSOException {
		logger.info("Test transaction");
		if (!sessionManager.getCurrentSession().isTransactionInProgress()) {
			logger.info("No transaction in progress");
			try {
				logger.info("Init a new transaction");
				// Instead of throwing an exception, start a new one
				sessionManager.getCurrentSession().setTransactionId(startTransaction());
				sessionManager.getCurrentSession().setTransactionInProgress(true);// Set the transaction in progress
			} catch (RCPparameterException e) {
				throw new NSOException(e);
			}
		}
	}

	/**
	 * Try a sync from but does not valid the devices Example : nso.syncFrom();
	 * 
	 * @return the sync from result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String syncFrom() throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), "/devices/sync-from"));
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		StringBuilder bld = new StringBuilder();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), NAME);
			String value = JsonPath.read(syncs.get(i), VALUE);
			if (type.compareTo("sync-result/device") == 0) {
				bld.append(value + ":");
			} else if (type.compareTo("sync-result/result") == 0) {
				bld.append(value + "\n");
			}
		}
		return bld.toString();
	}

	/**
	 * Execute sync from on a specific device
	 * 
	 * @param deviceName the device name on NSO
	 * @return a boolean, true if the device in in Sync, false if not
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public boolean syncFrom(String deviceName) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(
				new RunAction(sessionManager.getTransactionId(), "/devices/device{" + deviceName + "}/sync-from"));
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		String processed = syncs.toJSONString();
		for (int i = 0; i < syncs.size(); i++) {
			String value = JsonPath.read(syncs.get(i), VALUE);
			processed = value;
		}
		return Boolean.valueOf(processed);
	}

	/**
	 * Run an action from NSO Example : nso.runAction("/devices/sync-from");
	 * 
	 * @param action - KeyPath String expression to the action
	 * @return the action result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String runAction(String action) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(new RunAction(sessionManager.getTransactionId(), action));
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		StringBuilder bld = new StringBuilder();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), NAME);
			String value = JsonPath.read(syncs.get(i), VALUE);
			bld.append(type + ":" + value);
		}
		return bld.toString();
	}

	/**
	 * Run an action from NSO with format Example :
	 * nso.runAction("/devices/sync-from","json");
	 * 
	 * @param action - KeyPath String expression to the action
	 * @param format - format "normal", "bracket", "json"
	 * @return the action result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong RPC parameter
	 */
	public String runAction(String action, String format) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), action, format));
		if (format.compareTo("json") == 0) {
			try {
				JSONObject processed = ResultParser.parseResult(result, RESULT);
				return processed.toJSONString();
			} catch (PathNotFoundException e) {// No path found
				throw new RPCException(result);
			}
		} else {
			return result;
		}
	}

	/**
	 * Run an action from NSO with format and params :
	 * nso.runAction("/services/test/deploy","json","{\"clockSettings\":
	 * \"2014-02-11T14:20:53.460%2B01:00\"}");
	 * 
	 * @param action - KeyPath String expression to the action
	 * @param format - format "normal", "bracket", "json"
	 * @param params The format params defines if the result should be an array of
	 *               key values or a pre-formatted string on bracket format as seen
	 *               in the CLI. Eg : {"clockSettings":
	 *               "2014-02-11T14:20:53.460%2B01:00"}
	 * @return the action result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong RPC parameter
	 */
	public String runAction(String action, String format, String params)
			throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), action, format, params));
		if (format.compareTo("json") == 0) {
			try {
				return tryParseResult(result);
			} catch (PathNotFoundException e) {// No path found
				throw new RPCException(result);
			}
		} else {
			return result;
		}
	}

	/**
	 * Try to parse the result (object or array)
	 * 
	 * @param result The result from the action
	 * @return the parsed result
	 */
	private String tryParseResult(String result) {
		try {
			JSONObject processed = ResultParser.parseResult(result, RESULT);
			return processed.toJSONString();
		} catch (Exception e) {
			JSONArray processed = JsonPath.read(result, RESULT_ARRAY);
			return processed.toJSONString();
		}
	}

	/**
	 * Load a file to NSO
	 * 
	 * Example :
	 * nso.load("/devices/device{devicename}","/tmp/device.xml","replace","xml");
	 * 
	 * @param path     - Keypath String expression
	 * @param filePath - path to the file (from the system calling it)
	 * @param mode     - "create","merge","replace"
	 * @param format   - "json","xml"
	 * @return the result
	 * @throws RCPparameterException Parameters related exception
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 */
	public String load(String path, String filePath, String mode, String format)
			throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(sessionManager.getTransactionId(), path, filePath, mode, format),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a payload to NSO
	 * 
	 * Example :
	 * nso.loadString("/devices/device{devicename}","{\"device"\:\"blah\"}","replace","xml");
	 * 
	 * @param path   - Keypath String expression
	 * @param data   - Payload
	 * @param mode   - "create","merge","replace"
	 * @param format - "json","xml"
	 * @return the result
	 * @throws RCPparameterException Parameters related exception
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 */
	public String loadString(String path, String data, String mode, String format)
			throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new LoadString(sessionManager.getTransactionId(), path, data, mode, format),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a file to NSO By default, the file will be merged, and using JSON. Use
	 * load(String path,String filePath,String mode,String format) for more options
	 * 
	 * Example : nso.load("/devices/device{devicename}","/tmp/device.json");
	 * 
	 * @param path     - KeyPath String expression
	 * @param filePath - path to the file (from the system calling it)
	 * @return the result
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException Parameters exception
	 * @throws NSOException          NSO related exception
	 */
	public String load(String path, String filePath) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(sessionManager.getTransactionId(), path, filePath, "merge", "json"),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a payload to NSO By default, the file will be merged, and using JSON.
	 * Use load(String path,String filePath,String mode,String format) for more
	 * options
	 * 
	 * Example :
	 * nso.loadString("/devices/device{devicename}","{\"device"\:\"blah\"}");
	 * 
	 * @param path - KeyPath String expression
	 * @param data - Payload
	 * @return the result
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException Parameters exception
	 * @throws NSOException          NSO related exception
	 */
	public String loadString(String path, String data) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(
				new LoadString(sessionManager.getTransactionId(), path, data, "merge", "json"),
				sessionManager.getCurrentReq());
	}

	/**
	 * Check the service sync
	 * 
	 * @param path - KeyPath String expression to the service
	 * @return check sync result
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String serviceCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), path + "/check-sync"));
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		StringBuilder bld = new StringBuilder();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), NAME);
			String value = JsonPath.read(syncs.get(i), VALUE);
			bld.append(type + ":" + value + " ");
		}
		return bld.toString();
	}

	/**
	 * Check the device synchronization
	 * 
	 * Return true on any case. Will return a RPCException if the device is out of
	 * sync.
	 * 
	 * @param device The device name
	 * @return The status
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 */
	public boolean deviceCheckSync(String device) throws RPCException, NSOException {
		String result = serviceCheckSync("/devices/device{" + device + "}");
		if (result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}

	/**
	 * Check the devices synchronization
	 * 
	 * Same as deviceCheckSync(String device), but return a RPCException if one of
	 * the device is out of sync.
	 * 
	 * @return The status
	 * @throws NSOException NSO related exception
	 * @throws RPCException RPC related exception
	 */
	public boolean deviceCheckSync() throws RPCException, NSOException {
		String result = serviceCheckSync("/devices");
		if (result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}

	/**
	 * Return deep check sync Example :
	 * nso.serviceDeepCheckSync("/services/myservice");
	 * 
	 * @param path - KeyPath String expression to the service
	 * @return The status
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String serviceDeepCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), path + "/deep-check-sync"));
		JSONObject error = ResultParser.parseError(result);
		// If no error
		if (error != null) {
			throw new RPCException(error.toString());
		}
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		StringBuilder bld = new StringBuilder();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), NAME);
			String value = JsonPath.read(syncs.get(i), VALUE);
			bld.append(type + ":" + value);
		}
		return bld.toString();
	}

	/**
	 * Call default live-status action (exec)
	 * 
	 * This works with any of the latest version of NSO. For the older version, you
	 * will need to use String liveStatus(String device, String cmd, String action)
	 * to specify the device type.(Ex: cisco-iosxr)
	 * 
	 * @param device - device name
	 * @param cmd    - command to send to the device
	 * @return live status result
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong parameters
	 */
	public String liveStatus(String device, String cmd) throws NSOException, RPCException, RCPparameterException {
		return this.liveStatus(device, cmd, "exec");
	}

	/**
	 * Can use different action (ex : exec, bigip-actions,...)
	 * 
	 * @param device - device name
	 * @param cmd    - command to send to the device
	 * @param action - exec, bigip-actions,...
	 * @return live status result
	 * @throws NSOException          NSO related exception
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException Wrong parameters
	 */
	public String liveStatus(String device, String cmd, String action)
			throws NSOException, RPCException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(),
						"/devices/device{" + device + "}/live-status/" + action + "/any/", "normal",
						"{\"args\": \"" + cmd + "\"}"));
		JSONArray syncs = JsonPath.read(result, RESULT_ARRAY);
		StringBuilder bld = new StringBuilder();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), NAME);
			String value = JsonPath.read(syncs.get(i), VALUE);
			if (type.compareTo("result") == 0) {
				bld.append(value);
			}
		}
		return bld.toString();
	}

	/**
	 * Check if a leaf exists
	 * 
	 * @param path - KeyPath String expression to the leaf
	 * @return a boolean representing the leaf
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public boolean exists(String path) throws RPCException, NSOException {
		String data = ResultParser.processRawData(new Exists(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
		return ResultParser.parseBool(data, "$.exists");
	}

	/**
	 * Log out from the NPC sessions This should always be called after your
	 * operations. If not, NSO will keep the session open.
	 * 
	 * @return returns the sessions or null if it does not exist
	 */
	public String logout() {
		StringBuilder bld = new StringBuilder();
		try {
			for (int i = 0; i < sessionManager.getSessionList().size(); i++) {
				bld.append(removeSessionList(i));
			}
			// Remove each session and rebuild the session manager
			sessionManager = new SessionManager();
			return bld.toString();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Remove the sessions list, but bypass with if doesn't exist
	 * 
	 * @param sessionIndex the session list index
	 * @throws NSOException
	 */
	private String removeSessionList(int sessionIndex) {
		String toReturn = "";
		try {
			toReturn = ResultParser.processRawData(new Logout(),
					sessionManager.getSessionList().get(sessionIndex).getReq());
		} catch (RPCException | NSOException e) {
			e.printStackTrace();
		}
		return toReturn;
	}

	/**
	 * Select a session from the session's list
	 * 
	 * @param index The index of the session
	 */
	public void useSession(int index) throws IndexOutOfBoundsException {
		logger.info("User session index: " + index);
		sessionManager.setIndex(index);
	}

	/**
	 * Show the config as a string (Default)
	 * 
	 * @param path - KeyPath String expression to the leaf
	 * @return the config
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String showConfig(String path) throws RPCException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new ShowConfig(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
		return ResultParser.parseStringResult(result, "$.config");
	}

	/**
	 * Show the config with operational option
	 * 
	 * @param path     - KeyPath String expression to the leaf
	 * @param withOper - display operational data
	 * @param resultAs - "string","json"
	 * @return the config
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong RPC parameter
	 */
	public String showConfig(String path, boolean withOper, String resultAs)
			throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = ResultParser.processRawData(
				new ShowConfig(sessionManager.getTransactionId(), path, withOper, resultAs),
				sessionManager.getCurrentReq());
		if (resultAs.compareTo("string") == 0) {
			return ResultParser.parseStringResult(result, "$.config");
		} else {
			JSONObject jO = JsonPath.parse(result).read("$.data", JSONObject.class);
			return jO.toJSONString();
		}
	}

	/**
	 * Equivalent to showConfig with operational flag set to true
	 * 
	 * @param path     - KeyPath String expression to the leaf
	 * @param resultAs - "string","json"
	 * @return the config
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong RPC parameter
	 */
	public String showRun(String path, String resultAs) throws RPCException, NSOException, RCPparameterException {
		return showConfig(path, true, resultAs);
	}

	/**
	 * Equivalent to showRun with default output as string
	 * 
	 * @param path - KeyPath String expression to the leaf
	 * @return the config as a string
	 * @throws RPCException          RPC related exception
	 * @throws NSOException          NSO related exception
	 * @throws RCPparameterException Wrong RPC parameter
	 */
	public String showRun(String path) throws RPCException, NSOException, RCPparameterException {
		return showRun(path, "string");
	}

	/**
	 * Show a specific device config as JSON string Example : String result =
	 * nso.showDeviceConfig("mydevice");
	 * 
	 * @param device The device name
	 * @return String JSON Value
	 * @throws RPCException RPC related exception
	 * @throws NSOException NSO related exception
	 */
	public String showDeviceConfig(String device) throws RPCException, NSOException {
		return showConfig("/devices/device/{" + device + "}");
	}

	/**
	 * Show the config (Can be "string" or "json")
	 * 
	 * @param path     - KeyPath String expression to the leaf
	 * @param resultAs - "string","json"
	 * @return the config
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException parameters exception
	 * @throws NSOException          NSO related exception
	 */
	public String showConfig(String path, String resultAs) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(
				new ShowConfig(sessionManager.getTransactionId(), path, false, resultAs),
				sessionManager.getCurrentReq());
		if (resultAs.compareTo("string") == 0) {
			return ResultParser.parseStringResult(result, "$.config");
		} else {
			JSONObject jO = JsonPath.parse(result).read("$.data", JSONObject.class);
			return jO.toJSONString();
		}
	}

	/**
	 * Return the NSOVersion
	 * 
	 * @return the nso version
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException parameters exception
	 * @throws NSOException          NSO related exception
	 */
	public String getNSOVersion() throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String parsedResult = ResultParser.parseStringResult(
				sessionManager.getCurrentReq().send(new GetSystemSetting(sessionManager.getTransactionId(), "version")),
				RESULT);
		// Version major and minor can be use to manage the capabilities from the
		// version used.
		this.majorVersion = Integer.parseInt(parsedResult.split("\\.")[0]);
		this.minorVersion = Integer.parseInt(parsedResult.split("\\.")[1]);
		return ResultParser.parseStringResult(
				sessionManager.getCurrentReq().send(new GetSystemSetting(sessionManager.getTransactionId(), "version")),
				RESULT);
	}

	/**
	 * Get the Minor NSO version Example : 4.5.3 : Minor is 5
	 * 
	 * @return the minor version
	 */
	public int getMinorVersion() {
		return this.minorVersion;
	}

	/**
	 * Get the Major NSO Version Example : 4.5.3 : Major is 4
	 * 
	 * @return the major version
	 */
	public int getMajorVersion() {
		return this.majorVersion;
	}

	/**
	 * Return the NSO Settings
	 * 
	 * @return The NSO settings
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException parameters exception
	 * @throws JsonPathException     Json path exception
	 * @throws NSOException          NSO related exception
	 */
	public String getNSOSettings() throws RPCException, JsonPathException, RCPparameterException, NSOException {
		testTransaction();
		return new JSONDisplay(ResultParser.processRawData(
				new GetSystemSetting(sessionManager.getTransactionId(), "all"), sessionManager.getCurrentReq()))
						.getJsonString();
	}

	/**
	 * Get the NSO capabilities
	 * 
	 * @return The NSO capabilities
	 * @throws RPCException          RPC related exception
	 * @throws RCPparameterException parameters exception
	 * @throws JsonPathException     Json path exception
	 * @throws NSOException          NSO related exception
	 */
	public String getNSOCapabilities() throws RPCException, JsonPathException, RCPparameterException, NSOException {
		testTransaction();
		return new JSONDisplay(
				ResultParser.processRawData(new GetSystemSetting(sessionManager.getTransactionId(), "capabilities"),
						sessionManager.getCurrentReq())).getJsonString();
	}

	/**
	 * Get NSOController library library version
	 * 
	 * @return the version
	 */
	public static String getVersion() {
		MavenXpp3Reader reader = new MavenXpp3Reader();
		String version = "0.0.0";
		try {
			Model model = reader.read(new FileReader("pom.xml"));
			version = model.getVersion();
		} catch (IOException | XmlPullParserException e) {
			e.printStackTrace();
		}
		return version;
	}

	/**
	 * Return the index of the current session
	 * 
	 * @return the current session
	 */
	public int getSessionIndex() {
		return sessionManager.getCurrentIndex();
	}

	/**
	 * Return the total sessions available
	 * 
	 * @return the current session list size
	 */
	public int getTotalSessions() {
		return sessionManager.getSessionList().size();
	}

	/**
	 * Get the session manager
	 * 
	 * @return A Session manager
	 */
	public SessionManager getSessionManager() {
		return sessionManager;
	}

	/**
	 * Expose the NSO representation
	 */
	@Override
	public String toString() {
		return "NSO (Network service orchestrator) version " + this.majorVersion + "." + this.minorVersion
				+ ".X, NSO Controller API v" + NSOController.getVersion();
	}
}
