package com.apaulin.nso_controller;

import java.io.IOException;

import com.apaulin.nso_controller.exception.NSOException;
import com.apaulin.nso_controller.http.RpcRequest;
import com.apaulin.nso_controller.http.RpcSession;
import com.apaulin.nso_controller.http.SessionManager;
import com.apaulin.nso_controller.http.StringArray;
import com.apaulin.nso_controller.http.rest.HTTPException;
import com.apaulin.nso_controller.http.rest.RestRequest;
import com.apaulin.nso_controller.http.rpc.Abort;
import com.apaulin.nso_controller.http.rpc.AppendListEntry;
import com.apaulin.nso_controller.http.rpc.Commit;
import com.apaulin.nso_controller.http.rpc.CommitOptions;
import com.apaulin.nso_controller.http.rpc.ConfirmCommit;
import com.apaulin.nso_controller.http.rpc.Create;
import com.apaulin.nso_controller.http.rpc.Delete;
import com.apaulin.nso_controller.http.rpc.Exists;
import com.apaulin.nso_controller.http.rpc.GetLeafRefValues;
import com.apaulin.nso_controller.http.rpc.GetListKeys;
import com.apaulin.nso_controller.http.rpc.GetSchema;
import com.apaulin.nso_controller.http.rpc.GetSystemSetting;
import com.apaulin.nso_controller.http.rpc.GetValue;
import com.apaulin.nso_controller.http.rpc.GetValues;
import com.apaulin.nso_controller.http.rpc.Load;
import com.apaulin.nso_controller.http.rpc.LoadString;
import com.apaulin.nso_controller.http.rpc.Logout;
import com.apaulin.nso_controller.http.rpc.NewTrans;
import com.apaulin.nso_controller.http.rpc.RCPparameterException;
import com.apaulin.nso_controller.http.rpc.RPCException;
import com.apaulin.nso_controller.http.rpc.RunAction;
import com.apaulin.nso_controller.http.rpc.SetTransactionComment;
import com.apaulin.nso_controller.http.rpc.SetValue;
import com.apaulin.nso_controller.http.rpc.ShowConfig;
import com.apaulin.nso_controller.http.rpc.ValidateCommit;
import com.apaulin.nso_controller.http.rpc.ValidateTrans;
import com.apaulin.nso_controller.json.JSONDisplay;
import com.apaulin.nso_controller.json.ResultParser;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.JsonPathException;
import com.jayway.jsonpath.PathNotFoundException;

import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;

/**
 * Controller of the NSO request. This is basically an abstraction layer for the
 * requests object with an extra control.
 * 
 * @author Anthony Paulin
 * @since 22/07/2018
 * @version 2.0
 * 
 */

public class NSOController {

	private SessionManager sessionManager = new SessionManager();
	private String address; // Address of the NSO instance. (http://IP:PORT)
	private String login; // Login used by the NSO instance (PAM or aaa database)
	private String password; // password used for the NSO instance (PAM or aaa database)
	private static final String VERSION = "4.3.1"; // Version of the library
	private int major_version;
	private int minor_version;
	public static final String ROBOT_LIBRARY_SCOPE = "GLOBAL"; // Scope used for Robot framework.

	/**
	 * Default constructor - Should be used only by robot framework when called as a
	 * test library. If you call it as a Java library, you should call
	 * NSOController(String address, String user, String password,(int id)) For
	 * Robot framework, you must call the method init(String address, String user,
	 * String password)
	 */
	public NSOController() {
	}

	/**
	 * Initialize the connection Example: NSOController nso = new
	 * NSOController("http://127.0.0.1:8080","admin","admin");
	 * 
	 * @param address
	 *            - Format http(s)://IP:PORT
	 * @param user
	 *            - username for the NSO connection
	 * @param password
	 *            - password for the NSO connection
	 * @throws NSOException
	 *             NSO related exception
	 */
	public NSOController(String address, String user, String password) throws NSOException {
		init(address, user, password);
	}

	/**
	 * Build the NSO Controller access Example: NSOController nso = new
	 * NSOController("http://127.0.0.1:8080","admin","admin",5);
	 * 
	 * selecting an ID can be used if you want to manage your own IDs, for example
	 * if you use a multi-threads process.
	 * 
	 * @param address
	 *            - Format http(s)://IP:PORT
	 * @param user
	 *            - username for the NSO connection
	 * @param password
	 *            - password for the NSO connection
	 * @param id
	 *            - The ID is used by RPC. But default it is a random integer
	 *            generated by the library.
	 * @throws NSOException
	 *             NSO related exception
	 */
	public NSOController(String address, String user, String password, int id) throws NSOException {
		createSession(address, user, password, id);
	}

	/**
	 * Initialize the connection This should only be used by robot framework to init
	 * a new object. For java, you should used the constructor NSOController(String
	 * address, String user, String password)
	 * 
	 * @param address
	 *            - Format http(s)://IP:PORT
	 * @param user
	 *            - username for the NSO connection
	 * @param password
	 *            - password for the NSO connection
	 * @throws NSOException
	 *             NSO related exception if there is a NSO connection exception
	 */
	public void init(String address, String user, String password) throws NSOException {
		createSession(address, user, password, sessionManager.setId());
	}

	/**
	 * Create the session
	 * 
	 * @param address
	 *            - Format http(s)://IP:PORT
	 * @param user
	 *            - username for the NSO connection
	 * @param password
	 *            - password for the NSO connection
	 * @throws NSOException
	 *             NSO related exception
	 */
	private void createSession(String address, String user, String password, int id) throws NSOException {
		this.address = address;
		this.login = user;
		this.password = password;
		RpcRequest request = new RpcRequest(address + "/jsonrpc", user, password, id);
		RpcSession session = new RpcSession(id, request);
		sessionManager.add(session);// Add the new session to the list of sessions
	}

	/**
	 * Add a new session
	 * 
	 * @throws NSOException
	 *             NSO related exception
	 */
	public void addSession() throws NSOException {
		int id = sessionManager.setId();
		RpcRequest request = new RpcRequest(address + "/jsonrpc", login, password, id);
		RpcSession session = new RpcSession(id, request);
		sessionManager.add(session);// Add the new session to the list of sessions
	}

	/**
	 * Get using REST API Example : String result = nso.restGet("/config/aaa");
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return return the request result (by default, in JSON String)
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restGet(String path) throws HTTPException, NSOException {
		// Test if the application supports application/vnd.yang.collection+json
		String header = restHead(path);
		String headerToUse = "application/vnd.yang.collection+json";
		if (header.compareTo("Content-Type: text/json") == 0) {
			headerToUse = "application/vnd.yang.data+json";
		}
		return new RestRequest().get(path, address, login, password, headerToUse);
	}

	/**
	 * Get the HEAD value of the equivalent of a GET request. Default value =
	 * "application/vnd.yang.collection+json" Can be use to determine the header
	 * required for GET Example : String result = nso.restHead("/config/aaa");
	 * 
	 * @param path
	 *            Path to the leaf
	 * @return THe header as a String Ex: "Content-Type: text/json"
	 * @throws NSOException
	 *             NSO related exception - for NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restHead(String path) throws HTTPException, NSOException {
		return restHead(path, "application/vnd.yang.collection+json");
	}

	/**
	 * Get the HEAD value of the equivalent of a GET request. Can be use to
	 * determine the header required for GET Example : String result =
	 * nso.restHead("/config/aaa","application/vnd.yang.collection+xml");
	 * 
	 * @param path
	 *            Path to the leaf
	 * @param request
	 *            The request format
	 * @return THe header as a String Ex: "Content-Type: text/xml"
	 * @throws NSOException
	 *             - NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restHead(String path, String request) throws HTTPException, NSOException {
		String req = null;
		try {
			req = new RestRequest().head(path, address, login, password, request);
		} catch (IOException e) {
			throw new NSOException(e);
		}
		return req;
	}

	/**
	 * Get using REST API Example : String result =
	 * nso.restHead("/config/aaa","application/vnd.yang.collection+json");
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param header
	 *            - http header requested / E.g :
	 *            application/vnd.yang.collection+json - Refer to the NSO
	 *            documentation for more information.
	 * @return The NSO response
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restGet(String path, String header) throws HTTPException, NSOException {
		return new RestRequest().get(path, address, login, password, header);
	}

	/**
	 * Validate the commit for the current transaction This will explicitely valide
	 * the commit before running it. Example : nso.validateCommit();
	 * nso.commitDryRunNative(); nso.validateCommit(); nso.commit();
	 * 
	 * @return JSON result of the commit validation
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception for NSO related exception
	 */
	public String validateCommit() throws RPCException, NSOException {
		testTransaction();
		String parsedResult = ResultParser.processRawData(new ValidateCommit(sessionManager.getTransactionId()),
				sessionManager.getCurrentReq());
		sessionManager.setCommitValidated(true);// Set the commit validation to true
		return parsedResult;
	}

	public String validateTransaction() throws RPCException, NSOException {
		testTransaction();
		String parsedResult = ResultParser.processRawData(new ValidateTrans(sessionManager.getTransactionId()),
				sessionManager.getCurrentReq());
		return parsedResult;
	}

	/**
	 * Commit the transaction If the commit validation has not been done before,
	 * this will run a commit validation. Example : nso.commit(); is equivalent to
	 * nso.validateCommmit(); nso.commit();
	 * 
	 * @param timeout
	 *            / If set to zero, need to confirm the commit
	 * @return The JSON Result form the commit
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commit(int timeout) throws RPCException, NSOException {
		testTransaction();
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), timeout),
				sessionManager.getCurrentReq());
		sessionManager.getCurrentSession().setTransactionInProgress(false);// If the commit is a success, the
																			// transaction is killed
		return commitResult;
	}

	/**
	 * Same as commit, but provides a Force LSA Option
	 * 
	 * @return The commit's result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commitLSA() throws RPCException, NSOException {
		CommitOptions options = new CommitOptions();
		options.addUseLSA();
		testTransaction();
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, 0),
				sessionManager.getCurrentReq());
		sessionManager.getCurrentSession().setTransactionInProgress(false);// If the commit is a success, the
																			// transaction is killed
		return commitResult;
	}

	/**
	 * Commit the transaction If the commit validation has not been done before,
	 * this will run a commit validation. Example : nso.commit(); is equivalent to
	 * nso.validateCommmit(); nso.commit();
	 * 
	 * The default timeout is 600.
	 * 
	 * @return The commit result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commit() throws RPCException, NSOException {
		return this.commit(0);
	}

	/**
	 * Simple commit
	 * 
	 * @param comment
	 *            comment to add
	 * @return The commit result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	@Deprecated
	public String commit(String comment) throws RPCException, NSOException {
		return this.commit();
	}

	/**
	 * Set the commit comment
	 * 
	 * @param comment
	 *            the comment to add
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String setComment(String comment) throws RPCException, NSOException {
		String result = ResultParser.processRawData(
				new SetTransactionComment(sessionManager.getTransactionId(), comment), sessionManager.getCurrentReq());
		return result;
	}

	/**
	 * Ping action to JRPC
	 * 
	 * @param device
	 *            The device Name
	 * @return The ping result as a String
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String ping(String device) throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/device{" + device + "}/ping");
	}

	/**
	 * Connect action to JRPC
	 * 
	 * @param device
	 *            The device Name
	 * @return The connect result as a String
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String connect(String device) throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/device{" + device + "}/connect");
	}

	/**
	 * Connect action to JRPC for all devices
	 * 
	 * @return The connect result as a String
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String connect() throws RPCException, NSOException {
		testTransaction();
		return runAction("/ncs:devices/connect");
	}

	/**
	 * Delete a leaf Example : nso.delete("/devices/device{myDevice}");
	 * 
	 * This is the equivalent of the NSO cisco CLI "no" in config mode
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return JSON string result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String delete(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Delete(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit dry run using the native format Example : nso.commitDryRunNative();
	 * This is equivalent of doing : nso.validateCommit(); nso.commitDryRunNative();
	 * 
	 * @param timeout
	 *            Set it to zero for version higher 4.7.X
	 * @return The command that the device will run
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commitDryRunNative(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("native");
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		return ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit dry run using the native format Example : nso.commitDryRunNative();
	 * This is equivalent of doing : nso.validateCommit(); nso.commitDryRunNative();
	 * 
	 * This set the default timeout at 600
	 * 
	 * @return Commit dry run result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commitDryRunNative() throws RPCException, NSOException {
		return this.commitDryRunNative(0);
	}

	/**
	 * Equivalent to dryRun();
	 * 
	 * @return commit dry run in cli format
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commitDryRunCli() throws RPCException, NSOException {
		return this.dryRun();
	}

	/**
	 * Equivalent to dryRun(int timeout);
	 * 
	 * @param timeout
	 *            the timeout in ms
	 * @return commit dry run in cli format
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             for NSO related exception
	 */
	public String commitDryRunCli(int timeout) throws RPCException, NSOException {
		return this.dryRun(timeout);
	}

	/**
	 * Run a dry run using the CLI (Default on NSO) option Prefer dry run native for
	 * JSON, because CLI will return a String using + - and is difficult to process.
	 * 
	 * @param timeout
	 *            the timeout in ms
	 * @return commit dry run in json (default)
	 * @throws NSOException
	 *             for NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String dryRun(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("cli");// Add CLI flag
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String rawData = ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
		String parsedResult = new String();
		try {
			// This is most probably a LSA output.
			if (rawData.contains("local_node") && rawData.contains("lsa_node")) {
				parsedResult = ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.local_node.data");
				parsedResult += ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.lsa_node.*.data");
			} else if (rawData.contains("local_node")) {
				parsedResult = ResultParser.parseStringResult(rawData, "$.dry_run_result.cli.local_node.data");
			} else {
				parsedResult = rawData;
			}
		} catch (Exception e) {
			e.printStackTrace();
			// In case of error, we process the rawData directly
			parsedResult = rawData;
		}
		return parsedResult;
	}

	/**
	 * Run a dry run using the CLI (Default on NSO) option Prefer dry run native for
	 * JSON, because CLI will return a String using + - and is difficult to process.
	 * 
	 * Default timeout 600
	 * 
	 * @return commit dry run (600ms default)
	 * @throws NSOException
	 *             for NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String dryRun() throws RPCException, NSOException {
		return this.dryRun(0);
	}

	/**
	 * Run a commit with the no networking flag (No modification on the device(s))
	 * 
	 * @param timeout
	 *            the timeout in ms
	 * @return The commit result from NSO
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String commitNoNetworking(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addNoNetworking();
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		String commitResult = ResultParser.processRawData(
				new Commit(sessionManager.getTransactionId(), options, timeout), sessionManager.getCurrentReq());
		sessionManager.getCurrentSession().setTransactionInProgress(false);// If the commit is a success, the
																			// transaction is killed
		return commitResult;
	}

	/**
	 * Run a commit with the no networking flag (No modification on the device(s))
	 * 
	 * default timeout : 600
	 * 
	 * @return The commit result from NSO
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String commitNoNetworking() throws RPCException, NSOException {
		return this.commitNoNetworking(0);
	}

	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse(); This is equivalent of doing :
	 * nso.validateCommit(); nso.commitDryRunReverse();
	 * 
	 * @param timeout
	 *            the timeout in ms
	 * @return the commit dry run reverse result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String commitDryRunReverse(int timeout) throws RPCException, NSOException {
		testTransaction();
		CommitOptions options = new CommitOptions();
		options.addDryRun("native");
		options.addDryRunReverse();
		if (sessionManager.isCommitValidated() == false) {
			validateCommit();
		}
		sessionManager.setCommitValidated(false);
		return ResultParser.processRawData(new Commit(sessionManager.getTransactionId(), options, timeout),
				sessionManager.getCurrentReq());
	}

	/**
	 * Commit Dry run Reverse (native) return what would be deleted from the device.
	 * Example : nso.commitDryRunReverse(); This is equivalent of doing :
	 * nso.validateCommit(); nso.commitDryRunReverse();
	 * 
	 * Default timeout 600
	 * 
	 * @return the commit dry run reverse result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String commitDryRunReverse() throws RPCException, NSOException {
		return this.commitDryRunReverse(0);
	}

	/**
	 * Return the packages with packages version Example : String packages =
	 * nso.getPackagesVersion();
	 * 
	 * @return List (as a string) of the packages
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 * 
	 *             TODO : Fix this
	 */
	public String getPackagesVersion() throws HTTPException, NSOException {
		String result = new RestRequest().get("/operational/packages/package/", address, login, password);
		JSONArray names = JsonPath.read(result, "$.collection.tailf-ncs:package[*].name");
		JSONArray versions = JsonPath.read(result, "$.collection.tailf-ncs:package[*].package-version");
		String processedResult = new String();
		for (int i = 0; i < names.size(); i++) {
			processedResult = processedResult + names.get(i) + " " + versions.get(i) + "\n";
		}
		return processedResult;
	}

	/**
	 * Return a list of device name on the NSO instance Example : String devices =
	 * nso.getDevicesSummary();
	 * 
	 * @return the device summary
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String getDevicesSummary() throws HTTPException, NSOException {
		String result = new RestRequest().get("/config/devices", address, login, password,
				"application/vnd.yang.data+json");
		JSONArray names = JsonPath.read(result, "$.tailf-ncs:devices.device[*].name");
		String processedResult = new String();
		for (int i = 0; i < names.size(); i++) {
			processedResult = processedResult + names.get(i) + "\n";
		}
		return processedResult;
	}

	/**
	 * TODO In progress
	 * 
	 * @param path
	 *            KeyPath String expression
	 * @return the list keys
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String getListKeys(String path) throws RPCException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new GetListKeys(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
		return result;
	}

	/**
	 * Append a list entry to a leaf-list.
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param value
	 *            - Value to add to the leaf
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public void appendListEntry(String path, String value) throws NSOException, RPCException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new AppendListEntry(sessionManager.getTransactionId(), path, value));
		JSONObject error = ResultParser.parseError(result);
		if (error != null) {
			throw new RPCException(error.toString());
		}
	}

	/**
	 * Gets all possible values for a leaf with a leafref type
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return the leaf ref values
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 * 
	 */
	public String getLeafRefValues(String path) throws NSOException, RPCException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new GetLeafRefValues(sessionManager.getTransactionId(), path));
		return result;
	}

	/**
	 * Confirms the currently pending confirmed commit
	 * 
	 * @return the confirm commit result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String confirmCommit() throws NSOException, RPCException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(new ConfirmCommit(sessionManager.getTransactionId()));
		return result;
	}

	/**
	 * Return the post request from the rest API
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the POST result
	 * @throws HTTPException
	 *             HTTP related exception
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String restPost(String path, String data) throws NSOException, HTTPException, RPCException {
		String result = new RestRequest().post(path, address, login, password, data);
		// If error
		if (result.contains("error-message")) {
			throw new RPCException(result);
		}
		return result;
	}

	/**
	 * Return the post request from the rest API
	 * 
	 * @param path
	 *            KeyPath String expression
	 * @return the post result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public String restPost(String path) throws NSOException, HTTPException, RPCException {
		return this.restPost(path, "{}");
	}

	/**
	 * Patch data via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (JSON format)
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public void restPatch(String path, String data) throws HTTPException, NSOException {
		try {
			new RestRequest().patch(path, address, login, password, data);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple patch
		}
	}

	/**
	 * Put data via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public void restPut(String path, String data) throws HTTPException, NSOException {
		try {
			new RestRequest().put(path, address, login, password, data);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple patch
		}
	}

	/**
	 * Put with dry run via REST This uses the native output by default
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the rest dry run
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPutDryRun(String path, String data) throws HTTPException, NSOException {
		return this.restPutDryRun(path, data, "native");
	}

	/**
	 * Put with dry run via REST
	 * 
	 * @param path
	 *            - Path
	 * @param data
	 *            - KeyPath String expression
	 * @param type
	 *            - type (cli, native)
	 * @return the rest dry run
	 * @throws HTTPException
	 *             HTTP related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String restPutDryRun(String path, String data, String type) throws HTTPException, NSOException {
		String result = new RestRequest().put(path + "?dryrun=" + type, address, login, password, data);
		return result;
	}

	/**
	 * Put with dry run native via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the rest5 dry run native
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPutDryRunNative(String path, String data) throws HTTPException, NSOException {
		return this.restPutDryRun(path, data);
	}

	/**
	 * Put with dry run cli via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the drun run cli
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPutDryRunCli(String path, String data) throws HTTPException, NSOException {
		return this.restPutDryRun(path, data, "cli");
	}

	/**
	 * Patch with dry run via REST Default native
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the patch dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPatchDryRun(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "native");
	}

	/**
	 * Patch with dry run via REST
	 * 
	 * @param path
	 *            - Path
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @param type
	 *            - type (cli, native)
	 * @return the patch dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPatchDryRun(String path, String data, String type) throws HTTPException, NSOException {
		String result = new RestRequest().patch(path + "?dryrun=" + type, address, login, password, data);
		return result;
	}

	/**
	 * Post with dry run via REST
	 * 
	 * @param path
	 *            - Path
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @param type
	 *            - type (cli, native)
	 * @return the patch dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPostDryRun(String path, String data, String type) throws HTTPException, NSOException {
		String result = new RestRequest().post(path + "?dryrun=" + type, address, login, password, data);
		return result;
	}

	/**
	 * Post with dry run cli via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the patch dry run result cli
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPosthDryRunCli(String path, String data) throws HTTPException, NSOException {
		return this.restPostDryRun(path, data, "cli");
	}

	/**
	 * Post with dry run native via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the patch dry run result native
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPostDryRunNative(String path, String data) throws HTTPException, NSOException {
		return this.restPostDryRun(path, data, "native");
	}

	/**
	 * Patch with dry run cli via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the patch dry run result cli
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPatchDryRunCli(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "cli");
	}

	/**
	 * Patch with dry run native via REST
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the patch dry run result native
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restPatchDryRunNative(String path, String data) throws HTTPException, NSOException {
		return this.restPatchDryRun(path, data, "native");
	}

	/**
	 * Delete a service using REST
	 * 
	 * @param path
	 *            - URL path to the service (Refer to the NSO doc for the http
	 *            request path) this is different to the KeyPath.
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public void restDelete(String path) throws HTTPException, NSOException {
		try {
			new RestRequest().delete("/config" + path, address, login, password);
		} catch (NullPointerException e) {
			// Null pointer Exception is expected, no answer from a simple delete
		}
	}

	/**
	 * Delete dry-run using rest Default native
	 * 
	 * @param path
	 *            - URL path to the service (Refer to the NSO doc for the http
	 *            request path) this is different to the KeyPath.
	 * @return The dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDeleteDryRun(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path, "native");
	}

	/**
	 * Delete dry-run using rest Default native
	 * 
	 * @param path
	 *            - URL path to the service (Refer to the NSO doc for the http
	 *            request path) this is different to the KeyPath.
	 * @param type
	 *            (cli,native)
	 * @return the delete dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDeleteDryRun(String path, String type) throws HTTPException, NSOException {
		return new RestRequest().delete("/config" + path + "?dryrun=" + type, address, login, password);
	}

	/**
	 * Delete dry-run native using rest
	 * 
	 * @param path
	 *            - URL path to the service (Refer to the NSO doc for the http
	 *            request path) this is different to the KeyPath.
	 * @return the delete dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDeleteDryRunNative(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path);
	}

	/**
	 * Delete dry-run cli using rest
	 * 
	 * @param path
	 *            - URL path to the service (Refer to the NSO doc for the http
	 *            request path) this is different to the KeyPath.
	 * @return the delete dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDeleteDryRunCli(String path) throws HTTPException, NSOException {
		return this.restDeleteDryRun(path, "cli");
	}

	/**
	 * Send data by REST and commit dry-run it (default native) (post)
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @return the dry run result
	 * @throws HTTPException
	 *             HTTP related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String restDryRun(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data, "native");
	}

	/**
	 * Send data by REST and commit dry-run it (post)
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Data payload to send (In JSON format)
	 * @param type
	 *            - type (cli,native)
	 * @return the dry run result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDryRun(String path, String data, String type) throws NSOException, HTTPException {
		String result = new RestRequest().post(path + "?dryrun=" + type, address, login, password, data);
		return result;
	}

	/**
	 * end data by REST and commit dry-run native (post)
	 * 
	 * @param path
	 *            the url path
	 * @param data
	 *            the json data
	 * @return the dry run result native
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDryRunNative(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data);
	}

	/**
	 * end data by REST and commit dry-run cli (post)
	 * 
	 * @param path
	 *            the url path
	 * @param data
	 *            the json data
	 * @return the dry run result cli
	 * @throws NSOException
	 *             NSO related exception
	 * @throws HTTPException
	 *             HTTP related exception
	 */
	public String restDryRunCli(String path, String data) throws NSOException, HTTPException {
		return this.restDryRun(path, data, "cli");
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - String data
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String setValue(String path, String data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Boolean value
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String setValue(String path, boolean data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Set a value to a leaf
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Integer value
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String setValue(String path, int data) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new SetValue(sessionManager.getTransactionId(), path, data),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get a leaf value
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param checkDefault
	 *            - Check default value
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getValue(String path, boolean checkDefault) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetValue(sessionManager.getTransactionId(), path, checkDefault),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get a leaf value
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getValue(String path) throws RPCException, NSOException {
		return getValue(path, true);
	}

	/**
	 * Get leaf values
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param leafs
	 *            - the leafs param is an array of children names residing under the
	 *            parent container in the YANG module
	 * @return result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getValues(String path, StringArray leafs) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetValues(sessionManager.getTransactionId(), path, leafs),
				sessionManager.getCurrentReq());
	}

	/**
	 * Get leaf values
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getValues(String path) throws RPCException, NSOException {
		return getValues(path, new StringArray());
	}

	/**
	 * Abort a JSON-RPC method by its associated id.
	 * 
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String abort() throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Abort(sessionManager.getCurrentSession().getId()),
				sessionManager.getCurrentReq());
	}

	/**
	 * Create a list entry, a presence container, or a leaf of type empty
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String create(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Create(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Start a new transaction
	 * 
	 * @param db
	 *            - "startup", "running", "candidate"
	 * @param mode
	 *            - "read", "read_write"
	 * @param conf_mode
	 *            - "private", "shared", "exclusive"
	 * @param tag
	 *            - Tag use for the rollback system
	 * @param on_pending_change
	 *            - "reuse", "reject", "discard"
	 * @return the transaction id
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             parameters exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public int startTransaction(String db, String mode, String conf_mode, String tag, String on_pending_change)
			throws NSOException, RPCException, RCPparameterException {
		String requestValue = sessionManager.getCurrentReq()
				.send(new NewTrans(db, mode, conf_mode, tag, on_pending_change));
		int th = 0;
		try {
			th = JsonPath.read(requestValue, "$.result.th");
			sessionManager.getCurrentSession().setTransactionId(th);
			sessionManager.getCurrentSession().setTransactionInProgress(true);// Set the transaction to true
		} catch (PathNotFoundException e) {
			throw new RPCException(requestValue);
		}
		getNSOVersion();// Initiate NSO version
		return th;// Return the transaction number
	}

	public int startTransaction() throws NSOException, RPCException, RCPparameterException {
		return startTransaction("running", "read_write", "private", "test", "reuse");
	}

	/**
	 * Get the data model
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @return the model
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getModel(String path) throws RPCException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new GetSchema(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
	}

	/**
	 * Test the transaction
	 * 
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	private void testTransaction() throws RPCException, NSOException {
		if (sessionManager.getCurrentSession().isTransactionInProgress() == false) {
			// throw new RPCException("No transaction initated, make sure you start a
			// transaction before any call");
			try {
				// Instead of throwing anexception, start a new one
				sessionManager.getCurrentSession().setTransactionId(startTransaction());
				sessionManager.getCurrentSession().setTransactionInProgress(true);// Set the transaction in progress
			} catch (RCPparameterException e) {
				throw new NSOException(e);
			}
		}
	}

	/**
	 * Try a sync from but does not valid the devices Example : nso.syncFrom();
	 * 
	 * @return the sync from result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String syncFrom() throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), "/devices/sync-from"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			if (type.compareTo("sync-result/device") == 0) {
				processed += value + ":";
			} else if (type.compareTo("sync-result/result") == 0) {
				processed += value + "\n";
			}
		}
		return processed;
	}

	/**
	 * Execute sync from on a specific device
	 * 
	 * @param deviceName
	 *            the device name on NSO
	 * @return a boolean, true if the device in in Sync, false if not
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public boolean syncFrom(String deviceName) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(
				new RunAction(sessionManager.getTransactionId(), "/devices/device{" + deviceName + "}/sync-from"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = syncs.toJSONString();
		for (int i = 0; i < syncs.size(); i++) {
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed = value;
		}
		return Boolean.valueOf(processed);
	}

	/**
	 * Run an action from NSO Example : nso.runAction("/devices/sync-from");
	 * 
	 * @param action
	 *            - KeyPath String expression to the action
	 * @return the action result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String runAction(String action) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(new RunAction(sessionManager.getTransactionId(), action));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value;
		}
		return processed;
	}

	/**
	 * Run an action from NSO with format Example :
	 * nso.runAction("/devices/sync-from","json");
	 * 
	 * @param action
	 *            - KeyPath String expression to the action
	 * @param format
	 *            - format "normal", "bracket", "json"
	 * @return the action result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String runAction(String action, String format) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), action, format));
		if (format.compareTo("json") == 0) {
			try {
				JSONObject processed = ResultParser.parseResult(result, "$.result");
				return processed.toJSONString();
			} catch (PathNotFoundException e) {// No path found
				throw new RPCException(result);
			}
		} else {
			return result;
		}
	}
	
	/**
	 * Run an action from NSO with format and params :
	 * nso.runAction("/services/test/deploy","json","{\"clockSettings\": \"2014-02-11T14:20:53.460%2B01:00\"}");
	 * 
	 * @param action
	 *            - KeyPath String expression to the action
	 * @param format
	 *            - format "normal", "bracket", "json"
	 * @param params
	 *            The format params defines if the result should be an array of key
	 *            values or a pre-formatted string on bracket format as seen in the
	 *            CLI. Eg : {"clockSettings": "2014-02-11T14:20:53.460%2B01:00"}
	 * @return the action result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RCPparameterException 
	 */
	public String runAction(String action,String format,String params) throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), action, format,params));
		if (format.compareTo("json") == 0) {
			try {
				JSONObject processed = ResultParser.parseResult(result, "$.result");
				return processed.toJSONString();
			} catch (PathNotFoundException e) {// No path found
				throw new RPCException(result);
			}
		} else {
			return result;
		}
	}

	/**
	 * Run an action from NSO but return raw output for custom processing
	 * 
	 * @param action
	 *            - KeyPath String expression to the action
	 * @return the action result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 * @deprecated
	 */
	
	public String runActionRaw(String action) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(new RunAction(sessionManager.getTransactionId(), action));
		return result;
	}

	/**
	 * Load a file to NSO
	 * 
	 * Example :
	 * nso.load("/devices/device{devicename}","/tmp/device.xml","replace","xml");
	 * 
	 * @param path
	 *            - Keypath String expression
	 * @param filePath
	 *            - path to the file (from the system calling it)
	 * @param mode
	 *            - "create","merge","replace"
	 * @param format
	 *            - "json","xml"
	 * @return the result
	 * @throws RCPparameterException
	 *             Parameters related exception
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String load(String path, String filePath, String mode, String format)
			throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(sessionManager.getTransactionId(), path, filePath, mode, format),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a payload to NSO
	 * 
	 * Example :
	 * nso.loadString("/devices/device{devicename}","{\"device"\:\"blah\"}","replace","xml");
	 * 
	 * @param path
	 *            - Keypath String expression
	 * @param data
	 *            - Payload
	 * @param mode
	 *            - "create","merge","replace"
	 * @param format
	 *            - "json","xml"
	 * @return the result
	 * @throws RCPparameterException
	 *             Parameters related exception
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String loadString(String path, String data, String mode, String format)
			throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new LoadString(sessionManager.getTransactionId(), path, data, mode, format),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a file to NSO By default, the file will be merged, and using JSON. Use
	 * load(String path,String filePath,String mode,String format) for more options
	 * 
	 * Example : nso.load("/devices/device{devicename}","/tmp/device.json");
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param filePath
	 *            - path to the file (from the system calling it)
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             Parameters exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String load(String path, String filePath) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(new Load(sessionManager.getTransactionId(), path, filePath, "merge", "json"),
				sessionManager.getCurrentReq());
	}

	/**
	 * Load a payload to NSO By default, the file will be merged, and using JSON.
	 * Use load(String path,String filePath,String mode,String format) for more
	 * options
	 * 
	 * Example :
	 * nso.loadString("/devices/device{devicename}","{\"device"\:\"blah\"}");
	 * 
	 * @param path
	 *            - KeyPath String expression
	 * @param data
	 *            - Payload
	 * @return the result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             Parameters exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String loadString(String path, String data) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		return ResultParser.processRawData(
				new LoadString(sessionManager.getTransactionId(), path, data, "merge", "json"),
				sessionManager.getCurrentReq());
	}

	/**
	 * Check the service sync
	 * 
	 * @param path
	 *            - KeyPath String expression to the service
	 * @return check sync result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String serviceCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), path + "/check-sync"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value + " ";
		}
		return processed;
	}

	/**
	 * Check the device synchronization
	 * 
	 * Return true on any case. Will return a RPCException if the device is out of
	 * sync.
	 * 
	 * @param device
	 *            The device name
	 * @return The status
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public boolean deviceCheckSync(String device) throws RPCException, NSOException {
		String result = serviceCheckSync("/devices/device{" + device + "}");
		if (result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}

	/**
	 * Check the devices synchronization
	 * 
	 * Same as deviceCheckSync(String device), but return a RPCException if one of
	 * the device is out of sync.
	 * 
	 * @return The status
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 */
	public boolean deviceCheckSync() throws RPCException, NSOException {
		String result = serviceCheckSync("/devices");
		if (result.contains("out-of-sync")) {
			throw new RPCException(result);
		}
		return true;
	}

	/**
	 * Return deep check sync Example :
	 * nso.serviceDeepCheckSync("/services/myservice");
	 * 
	 * @param path
	 *            - KeyPath String expression to the service
	 * @return The status
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String serviceDeepCheckSync(String path) throws RPCException, NSOException {
		testTransaction();
		String result = sessionManager.getCurrentReq()
				.send(new RunAction(sessionManager.getTransactionId(), path + "/deep-check-sync"));
		JSONObject error = ResultParser.parseError(result);
		// If no error
		if (error != null) {
			throw new RPCException(error.toString());
		}
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			processed += type + ":" + value;
		}
		return processed;
	}

	/**
	 * Call default live-status action (exec)
	 * 
	 * This works with any of the latest version of NSO. For the older version, you
	 * will need to use String liveStatus(String device, String cmd, String action)
	 * to specify the device type.(Ex: cisco-iosxr)
	 * 
	 * @param device
	 *            - device name
	 * @param cmd
	 *            - command to send to the device
	 * @return live status result
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RCPparameterException
	 *             Wrong parameters
	 */
	public String liveStatus(String device, String cmd) throws NSOException, RPCException, RCPparameterException {
		return this.liveStatus(device, cmd, "exec");
	}

	/**
	 * Can use different action (ex : exec, bigip-actions,...)
	 * 
	 * @param device
	 *            - device name
	 * @param cmd
	 *            - command to send to the device
	 * @param action
	 *            - exec, bigip-actions,...
	 * @return live status result
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             Wrong parameters
	 */
	public String liveStatus(String device, String cmd, String action)
			throws NSOException, RPCException, RCPparameterException {
		testTransaction();
		String result = sessionManager.getCurrentReq().send(new RunAction(sessionManager.getTransactionId(),
				"/devices/device{" + device + "}/live-status/" + action + "/any/", 
				"{\"args\": \"" +cmd+ "\"}",
				"normal"));
		JSONArray syncs = JsonPath.read(result, "$.result[*]");
		String processed = new String();
		for (int i = 0; i < syncs.size(); i++) {
			String type = JsonPath.read(syncs.get(i), "$.name");
			String value = JsonPath.read(syncs.get(i), "$.value");
			if (type.compareTo("result") == 0) {
				processed += value;
			}
		}
		return processed;
	}
	


	/**
	 * Check if a leaf exists
	 * 
	 * @param path
	 *            - KeyPath String expression to the leaf
	 * @return a boolean representing the leaf
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public boolean isExisting(String path) throws RPCException, NSOException {
		String data = ResultParser.processRawData(new Exists(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
		boolean result = ResultParser.parseBool(data, "$.exists");
		return result;
	}

	/**
	 * Log out from the NPC sessions This should always be called after your
	 * operations. If not, NSO will keep the session open.
	 * 
	 * @return returns the sessions or null if it does not exist
	 */
	public String logout() {
		String back = new String();
		try {
			for (int i = 0; i < sessionManager.getSessionList().size(); i++) {
				// This will remove the sessions list, but will bypass with the catch if the
				// don't exists
				try {
					back += ResultParser.processRawData(new Logout(), sessionManager.getSessionList().get(i).getReq());
				} catch (RPCException e) {
					e.printStackTrace();
				}
			}
			// Remove each session and rebuild the session manager
			sessionManager = new SessionManager();
			return back;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Select a session from the session's list
	 * 
	 * @param index
	 *            The index of the session
	 */
	public void useSession(int index) throws IndexOutOfBoundsException {
		sessionManager.setIndex(index);
	}

	/**
	 * Show the config as a string (Default)
	 * 
	 * @param path
	 *            - KeyPath String expression to the leaf
	 * @return the config
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String showConfig(String path) throws RPCException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(new ShowConfig(sessionManager.getTransactionId(), path),
				sessionManager.getCurrentReq());
		return ResultParser.parseStringResult(result, "$.config");
	}

	/**
	 * Show the config with operational option
	 * 
	 * @param path
	 *            - KeyPath String expression to the leaf
	 * @param withOper
	 *            - display operational data
	 * @param resultAs
	 *            - "string","json"
	 * @return the config
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 * @throws RCPparameterException
	 *             Wrong RPC parameter
	 */
	public String showConfig(String path, boolean withOper, String resultAs)
			throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String result = ResultParser.processRawData(
				new ShowConfig(sessionManager.getTransactionId(), path, withOper, resultAs),
				sessionManager.getCurrentReq());
		if (resultAs.compareTo("string") == 0) {
			return ResultParser.parseStringResult(result, "$.config");
		} else {
			JSONObject jO = JsonPath.parse(result).read("$.data", JSONObject.class);
			return jO.toJSONString();
		}
	}

	/**
	 * Show a specific device config as JSON string Example : String result =
	 * nso.showDeviceConfig("mydevice");
	 * 
	 * @param device
	 *            The device name
	 * @return String JSON Value
	 * @throws RPCException
	 *             RPC related exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String showDeviceConfig(String device) throws RPCException, NSOException {
		return showConfig("/devices/device/{" + device + "}");
	}

	/**
	 * Show the config (Can be "string" or "json")
	 * 
	 * @param path
	 *            - KeyPath String expression to the leaf
	 * @param resultAs
	 *            - "string","json"
	 * @return the config
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             parameters exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String showConfig(String path, String resultAs) throws RPCException, RCPparameterException, NSOException {
		testTransaction();
		String result = ResultParser.processRawData(
				new ShowConfig(sessionManager.getTransactionId(), path, resultAs, false, 0),
				sessionManager.getCurrentReq());
		if (resultAs.compareTo("string") == 0) {
			return ResultParser.parseStringResult(result, "$.config");
		} else {
			JSONObject jO = JsonPath.parse(result).read("$.data", JSONObject.class);
			return jO.toJSONString();
		}
	}

	/**
	 * Return the NSOVersion
	 * 
	 * @return the nso version
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             parameters exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getNSOVersion() throws RPCException, NSOException, RCPparameterException {
		testTransaction();
		String parsedResult = ResultParser.parseStringResult(
				sessionManager.getCurrentReq().send(new GetSystemSetting(sessionManager.getTransactionId(), "version")),
				"$.result");
		// Version major and minor can be use to manage the capabilities from the NSO
		// version used.
		this.major_version = Integer.parseInt(parsedResult.split("\\.")[0]);
		this.minor_version = Integer.parseInt(parsedResult.split("\\.")[1]);
		return ResultParser.parseStringResult(
				sessionManager.getCurrentReq().send(new GetSystemSetting(sessionManager.getTransactionId(), "version")),
				"$.result");
	}

	/**
	 * Get the Minor NSO version Example : 4.5.3 : Minor is 5
	 * 
	 * @return the minor version
	 */
	public int getMinorVersion() {
		return this.minor_version;
	}

	/**
	 * Get the Major NSO Version Example : 4.5.3 : Major is 4
	 * 
	 * @return the major version
	 */
	public int getMajorVersion() {
		return this.major_version;
	}

	/**
	 * Return the NSO Settings
	 * 
	 * @return The NSO settings
	 * @throws RPCException
	 *             RPC related exception
	 * @throws RCPparameterException
	 *             parameters exception
	 * @throws JsonPathException
	 *             Json path exception
	 * @throws NSOException
	 *             NSO related exception
	 */
	public String getNSOSettings() throws RPCException, JsonPathException, RCPparameterException, NSOException {
		testTransaction();
		return new JSONDisplay(ResultParser.processRawData(
				new GetSystemSetting(sessionManager.getTransactionId(), "all"), sessionManager.getCurrentReq()))
						.getJsonString();
	}

	public String getNSOCapabilities() throws RPCException, JsonPathException, RCPparameterException, NSOException {
		testTransaction();
		return new JSONDisplay(
				ResultParser.processRawData(new GetSystemSetting(sessionManager.getTransactionId(), "capabilities"),
						sessionManager.getCurrentReq())).getJsonString();
	}

	/**
	 * Get NSOController library library version
	 * 
	 * @return the version
	 */
	public static String getVersion() {
		return VERSION;
	}

	/**
	 * Return the index of the current session
	 * 
	 * @return the current session
	 */
	public int getSessionIndex() {
		return sessionManager.getCurrentIndex();
	}

	/**
	 * Return the total sessions available
	 * 
	 * @return the current session list size
	 */
	public int getTotalSessions() {
		return sessionManager.getSessionList().size();
	}

	/**
	 * Expose the NSO representation
	 */
	@Override
	public String toString() {
		return "NSO (Network service orchestrator) version " + this.major_version + "." + this.minor_version
				+ ".X, NSO Controller API v" + VERSION;
	}
}
